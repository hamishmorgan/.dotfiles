---
description: "Testing requirements and test-driven development workflow"
globs: ["tests/**/*", "**/*.bats", "dot", "bin/*", "dev/*"]
---

# Testing Workflow

## When to Write Tests

**Always write tests for:**

1. **Bug Fixes (Regression Tests)** - Write failing test BEFORE implementing fix
   - Create test that reproduces the bug
   - Verify test fails
   - Implement fix
   - Verify test passes
   - Prevents bug from returning
   - Example: `tests/regression/test_issue_66.bats`

2. **New Functions (Unit Tests)** - Write tests for critical helper functions
   - Test edge cases and error conditions
   - Verify return values and side effects
   - Example: `tests/unit/test_backup_functions.bats`

3. **New Commands (Integration Tests)** - Test full command workflows
   - Verify exit codes
   - Validate output format
   - Example: `tests/integration/test_health.bats`

4. **Output Changes (Contract Tests)** - Update when changing user-facing output
   - Ensure output format stability
   - Verify required sections present
   - Example: `tests/contract/test_health_output.bats`

## Test-Driven Bug Fixing Pattern

**Critical:** Write failing regression test before fixing bugs.

```bash
# 1. Create regression test that demonstrates the bug
cat > tests/regression/test_issue_XX.bats << 'EOF'
@test "Issue #XX: describe the bug" {
    # Setup to reproduce bug
    create_mock_backups 15 1
    
    run ./dot health
    
    # This FAILS on the bug (what we want)
    assert_output_not_contains "using 0MB"
}
EOF

# 2. Run test - should FAIL
bats tests/regression/test_issue_XX.bats
# Expected: FAIL (bug present)

# 3. Fix the bug in code
# (make your changes)

# 4. Run test again - should PASS
bats tests/regression/test_issue_XX.bats
# Expected: PASS (bug fixed)

# 5. Commit both test and fix together
git add tests/regression/test_issue_XX.bats
git add dot  # or whatever file was fixed
git commit -m "Fix Issue #XX with regression test"
```

## Critical Testing Principles

**DO NOT create "acceptable failure" tests:**

```bash
# ❌ BAD: Allowing either success or failure
run ./dot health
[[ "$status" -eq 0 || "$status" -eq 1 ]]  # This is an anti-pattern!

# ✅ GOOD: Test specific behavior
# If testing backup display, test the function directly
source_dot_script
run get_backup_stats
assert_success
assert_output --regexp "[0-9]+ [0-9]+"

# ✅ GOOD: Or ensure proper test environment
./dot install > /dev/null 2>&1  # Set up environment
run ./dot health
# Now health should have deterministic result
```

**Tests must have clear expectations:**

- If a command should succeed, assert `assert_success`
- If a command should fail, assert `assert_failure` (exit code 1)
- Never use `[[ "$status" -eq 0 || "$status" -eq 1 ]]` as a cop-out
- If environment affects results, mock/set up the environment properly

**Test functions in isolation when possible:**

- Integration tests test full commands (slower, environmental dependencies)
- Unit tests test functions directly (faster, more reliable)
- Prefer unit tests for specific functionality
- Use integration tests for end-to-end workflows

Before (anti-pattern):

```bash
@test "health shows backups" {

    run ./dot health
    # May fail in test env - BAD!
    [[ "$status" -eq 0 || "$status" -eq 1 ]]

    assert_output --partial "15 backups"
}
```

After (correct):

```bash
@test "get_backup_stats returns correct values" {
    create_mock_backups 15 1
    source_dot_script
    run get_backup_stats
    assert_success  # Function must succeed
    count=$(echo "$output" | awk '{print $1}')
    assert_equal "15" "$count"
}
```

## Reference

See AGENTS.md for:

- Running Tests (command reference)
- Test Categories (taxonomy)
- Testing Strategy (philosophy)
- Why This Matters (context)
- Test Documentation (comprehensive framework docs)
