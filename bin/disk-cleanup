#!/usr/bin/env bash
# Disk space cleanup utility for developers
# Version: 1.0.0
#
# Safely cleans developer tool caches, build artifacts, and temporary files
# Supports macOS and Linux with multiple aggression levels

# Verify bash version (requires 3.2+)
if [[ "${BASH_VERSINFO[0]}" -lt 3 || ( "${BASH_VERSINFO[0]}" -eq 3 && "${BASH_VERSINFO[1]}" -lt 2 ) ]]; then
  echo "Error: This script requires bash 3.2 or later"
  echo "Current version: $BASH_VERSION"
  exit 2
fi

# Safer glob handling
shopt -s nullglob
shopt -s extglob

# Script metadata
readonly VERSION="1.0.0"
readonly SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors for output (match ./dot script)
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

# Status symbols (match ./dot script)
readonly SYMBOL_SUCCESS='✓'
readonly SYMBOL_ERROR='✗'
readonly SYMBOL_WARNING='⚠'
readonly SYMBOL_INFO='∙'

# Environment variable configuration
# Pattern: External = CLEANUP_ + Internal name

# Timeouts (seconds)
readonly GIT_GC_TIMEOUT="${CLEANUP_GIT_GC_TIMEOUT:-300}"
readonly DOCKER_TIMEOUT="${CLEANUP_DOCKER_TIMEOUT:-300}"
readonly BREW_TIMEOUT="${CLEANUP_BREW_TIMEOUT:-600}"
readonly DEFAULT_TIMEOUT="${CLEANUP_DEFAULT_TIMEOUT:-120}"

# Git discovery
readonly GIT_MAX_DEPTH="${CLEANUP_GIT_MAX_DEPTH:-3}"
readonly GIT_LOCATIONS="${CLEANUP_GIT_LOCATIONS:-$HOME/Projects:$HOME/src:$HOME/Developer:$HOME/Code:$HOME/workspace:$HOME/world:$HOME/.dotfiles}"

# Logging
readonly LOG_DIR="${CLEANUP_LOG_DIR:-$HOME/.cache/dev-cleanup}"
readonly KEEP_LOGS="${CLEANUP_KEEP_LOGS:-10}"

# Display
readonly OUTPUT_PREFIX="${CLEANUP_OUTPUT_PREFIX:-│ }"

# System cache estimates (MB)
readonly THUMBNAIL_CACHE_ESTIMATE="${CLEANUP_THUMBNAIL_CACHE_ESTIMATE:-150}"
readonly FONT_CACHE_ESTIMATE="${CLEANUP_FONT_CACHE_ESTIMATE:-100}"

# Platform detection
readonly PLATFORM="$(uname -s | tr '[:upper:]' '[:lower:]')"
readonly IS_MACOS="$([[ "$PLATFORM" == "darwin" ]] && echo "true" || echo "false")"
readonly IS_LINUX="$([[ "$PLATFORM" == "linux" ]] && echo "true" || echo "false")"

# State tracking
declare -a CLEANUP_RESULTS=()
TOTAL_SAVED_KB=0
OPERATION_COUNT=0
CURRENT_OPERATION=0
DRY_RUN=false
VERBOSE=false
QUIET=false
NON_INTERACTIVE=false
AGGRESSIVE=false
VERY_AGGRESSIVE=false
PRUNE_GIT=false
AGGRESSIVE_GIT=false
SYSTEM_CACHES=false
DETAILED_SPACE=false
declare -a ONLY_CATEGORIES=()
declare -a EXCLUDE_CATEGORIES=()

# Log file
LOG_FILE=""

#==============================================================================
# Logging Functions (match ./dot script style)
#==============================================================================

log_info() {
  [[ $QUIET == true ]] && return
  echo -e "${BLUE}${SYMBOL_INFO}${NC} $1"
}

log_success() {
  [[ $QUIET == true ]] && return
  echo -e "${GREEN}${SYMBOL_SUCCESS}${NC} $1"
}

log_warning() {
  echo -e "${YELLOW}${SYMBOL_WARNING}${NC} $1" >&2
}

log_error() {
  echo -e "${RED}${SYMBOL_ERROR}${NC} $1" >&2
}

# Log to file
log_to_file() {
  if [[ -n "$LOG_FILE" ]]; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE"
  fi
}

# Progress indicator
log_progress() {
  local description="$1"
  local status="${2:-}"
  local size="${3:-}"

  ((CURRENT_OPERATION++))

  if [[ $QUIET == true ]]; then
    return
  fi

  local progress="[$CURRENT_OPERATION/$OPERATION_COUNT]"

  if [[ -n "$status" ]]; then
    case "$status" in
      success)
        if [[ -n "$size" ]]; then
          echo -e "$progress ${GREEN}${SYMBOL_SUCCESS}${NC} $description$(printf '%*s' $((50 - ${#description})) '')$size"
        else
          echo -e "$progress ${GREEN}${SYMBOL_SUCCESS}${NC} $description"
        fi
        ;;
      skipped)
        echo -e "$progress ${BLUE}${SYMBOL_INFO}${NC} $description$(printf '%*s' $((50 - ${#description})) '')$size"
        ;;
      warning)
        echo -e "$progress ${YELLOW}${SYMBOL_WARNING}${NC} $description$(printf '%*s' $((50 - ${#description})) '')$size"
        ;;
      error)
        echo -e "$progress ${RED}${SYMBOL_ERROR}${NC} $description$(printf '%*s' $((50 - ${#description})) '')$size"
        ;;
    esac
  else
    echo -e "$progress Checking $description..."
  fi
}

#==============================================================================
# Helper Functions
#==============================================================================

# Get disk usage in GB
get_disk_usage() {
  local usage
  if [[ "$IS_MACOS" == "true" ]]; then
    usage=$(df -H / | tail -1 | awk '{print $3}' | tr -d 'G')
  else
    usage=$(df -BG / | tail -1 | awk '{print $3}' | tr -d 'G')
  fi
  echo "$usage"
}

# Convert KB to human-readable format
human_readable_size() {
  local kb=$1
  local size

  if ((kb >= 1048576)); then
    size=$(awk "BEGIN {printf \"%.1f GB\", $kb/1048576}")
  elif ((kb >= 1024)); then
    size=$(awk "BEGIN {printf \"%.0f MB\", $kb/1024}")
  else
    size="${kb} KB"
  fi

  echo "$size"
}

# Measure directory size in KB
measure_dir_size() {
  local path="$1"

  if [[ ! -d "$path" ]]; then
    echo "0"
    return
  fi

  local size
  size=$(du -sk "$path" 2>/dev/null | cut -f1)
  echo "${size:-0}"
}

# Run command with timeout
run_with_timeout() {
  local timeout=$1
  shift
  local cmd=("$@")

  if command -v timeout >/dev/null 2>&1; then
    timeout "$timeout" "${cmd[@]}"
    return $?
  else
    # Fallback for systems without timeout command
    "${cmd[@]}"
    return $?
  fi
}

# Confirm operation (interactive mode only)
confirm_operation() {
  local prompt="$1"
  local default="${2:-n}"

  if [[ $NON_INTERACTIVE == true ]]; then
    return 1  # Don't proceed with destructive ops in non-interactive mode
  fi

  local response
  if [[ "$default" == "y" ]]; then
    read -p "$prompt (Y/n): " -n 1 -r response
  else
    read -p "$prompt (y/N): " -n 1 -r response
  fi
  echo

  if [[ -z "$response" ]]; then
    response="$default"
  fi

  [[ "$response" =~ ^[Yy]$ ]]
}

# Find git repositories
find_git_repos() {
  local locations repos
  IFS=':' read -ra locations <<< "$GIT_LOCATIONS"

  repos=()
  for loc in "${locations[@]}"; do
    # Expand tilde
    loc="${loc/#\~/$HOME}"

    if [[ -d "$loc" ]]; then
      # Check if location itself is a git repo
      if [[ -d "$loc/.git" ]]; then
        repos+=("$loc")
      fi

      # Find git directories
      while IFS= read -r -d '' repo; do
        repos+=("$(dirname "$repo")")
      done < <(find "$loc" -maxdepth "$GIT_MAX_DEPTH" -name .git -type d -print0 2>/dev/null)
    fi
  done

  # Remove duplicates and sort
  printf '%s\n' "${repos[@]}" | sort -u
}

# Count total operations
count_operations() {
  local count=0

  # Package managers
  command -v brew >/dev/null 2>&1 && ((count++))
  command -v apt-get >/dev/null 2>&1 && ((count++))
  command -v yum >/dev/null 2>&1 && ((count++))
  command -v dnf >/dev/null 2>&1 && ((count++))

  # Language tools
  command -v npm >/dev/null 2>&1 && ((count++))
  command -v yarn >/dev/null 2>&1 && ((count++))
  command -v pnpm >/dev/null 2>&1 && ((count++))
  command -v gem >/dev/null 2>&1 && ((count++))
  command -v pip >/dev/null 2>&1 && ((count++))
  command -v pip3 >/dev/null 2>&1 && ((count++))
  command -v go >/dev/null 2>&1 && ((count++))
  command -v composer >/dev/null 2>&1 && ((count++))

  # Build tools
  command -v bundle >/dev/null 2>&1 && ((count++))
  command -v ccache >/dev/null 2>&1 && ((count++))

  # Git repos
  local repos
  repos=$(find_git_repos)
  if [[ -n "$repos" ]]; then
    count=$((count + $(echo "$repos" | wc -l)))
  fi

  # Docker/Podman
  command -v docker >/dev/null 2>&1 && ((count++))
  command -v podman >/dev/null 2>&1 && ((count++))

  # System caches
  if [[ "$IS_MACOS" == "true" ]]; then
    ((count += 2))  # Thumbnail and font cache
  fi

  # Xcode (macOS)
  if [[ "$IS_MACOS" == "true" ]] && xcode-select -p >/dev/null 2>&1; then
    ((count += 3))  # Simulators, derived data, archives
  fi

  # Shopify
  command -v dev >/dev/null 2>&1 && ((count++))
  command -v spin >/dev/null 2>&1 && ((count++))

  echo "$count"
}

#==============================================================================
# Cleanup Operations
#==============================================================================

# Generic cleanup wrapper
run_cleanup() {
  local name="$1"
  local cleanup_cmd="$2"
  local cache_path="${3:-}"
  local timeout="${4:-$DEFAULT_TIMEOUT}"
  local requires_confirm="${5:-false}"

  log_progress "$name"
  log_to_file "Running: $cleanup_cmd"

  # Dry run
  if [[ $DRY_RUN == true ]]; then
    log_progress "$name" "skipped" "Would run: $cleanup_cmd"
    log_to_file "DRY RUN: $cleanup_cmd"
    return 0
  fi

  # Confirmation if required
  if [[ "$requires_confirm" == "true" ]] && ! confirm_operation "Clean $name?"; then
    log_progress "$name" "skipped" "User declined"
    log_to_file "SKIPPED: User declined"
    return 0
  fi

  # Measure space if detailed mode and cache path provided
  local before_kb=0 after_kb=0 saved_kb=0
  if [[ $DETAILED_SPACE == true ]] && [[ -n "$cache_path" ]]; then
    before_kb=$(measure_dir_size "$cache_path")
  fi

  # Run cleanup
  local output exit_code
  output=$(run_with_timeout "$timeout" bash -c "$cleanup_cmd" 2>&1)
  exit_code=$?

  # Measure after
  if [[ $DETAILED_SPACE == true ]] && [[ -n "$cache_path" ]]; then
    after_kb=$(measure_dir_size "$cache_path")
    saved_kb=$((before_kb - after_kb))
    TOTAL_SAVED_KB=$((TOTAL_SAVED_KB + saved_kb))
  fi

  # Process result
  if [[ $exit_code -eq 0 ]]; then
    if [[ $saved_kb -gt 0 ]] || [[ "$output" =~ [0-9]+.*([MGK]B|bytes) ]]; then
      # Try to parse size from output
      local parsed_size
      if [[ "$output" =~ ([0-9.]+)[[:space:]]*(GB|MB|KB) ]]; then
        parsed_size="${BASH_REMATCH[1]} ${BASH_REMATCH[2]}"
        log_progress "$name" "success" "$parsed_size cleaned"
      elif [[ $saved_kb -gt 0 ]]; then
        log_progress "$name" "success" "$(human_readable_size $saved_kb) cleaned"
      else
        log_progress "$name" "success" "completed"
      fi
    else
      log_progress "$name" "success" "completed"
    fi
    log_to_file "SUCCESS: $name (exit code: $exit_code)"
    if [[ $VERBOSE == true ]] && [[ -n "$output" ]]; then
      while IFS= read -r line; do
        echo "${OUTPUT_PREFIX}${line}"
      done <<< "$output"
    fi
    return 0
  else
    log_progress "$name" "error" "Failed (exit $exit_code)"
    log_to_file "ERROR: $name (exit code: $exit_code)"
    log_to_file "Output: $output"
    if [[ $VERBOSE == true ]] && [[ -n "$output" ]]; then
      while IFS= read -r line; do
        echo "${OUTPUT_PREFIX}${line}"
      done <<< "$output" >&2
    fi
    return 1
  fi
}

# Skip with estimate
skip_with_estimate() {
  local name="$1"
  local estimate_mb="$2"
  local reason="$3"

  log_progress "$name" "skipped" "~${estimate_mb} MB potential ($reason)"
  log_to_file "SKIPPED: $name ($reason, estimated ${estimate_mb}MB)"
}

#==============================================================================
# Category: Package Managers
#==============================================================================

cleanup_package_managers() {
  [[ $QUIET == false ]] && echo -e "\n${BLUE}Package Managers${NC}"
  [[ $QUIET == false ]] && echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  if command -v brew >/dev/null 2>&1; then
    run_cleanup "Homebrew cache" "brew cleanup -s" "$(brew --cache 2>/dev/null)" "$BREW_TIMEOUT"
  fi

  if command -v apt-get >/dev/null 2>&1; then
    run_cleanup "apt cache" "sudo apt-get clean && sudo apt-get autoclean" "/var/cache/apt"
  fi

  if command -v yum >/dev/null 2>&1; then
    run_cleanup "yum cache" "sudo yum clean all" "/var/cache/yum"
  fi

  if command -v dnf >/dev/null 2>&1; then
    run_cleanup "dnf cache" "sudo dnf clean all" "/var/cache/dnf"
  fi
}

#==============================================================================
# Category: Language Tools
#==============================================================================

cleanup_language_tools() {
  [[ $QUIET == false ]] && echo -e "\n${BLUE}Language Tools${NC}"
  [[ $QUIET == false ]] && echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  if command -v npm >/dev/null 2>&1; then
    run_cleanup "npm cache" "npm cache clean --force" "$HOME/.npm"
  fi

  if command -v yarn >/dev/null 2>&1; then
    run_cleanup "yarn cache" "yarn cache clean" "$HOME/.yarn/cache"
  fi

  if command -v pnpm >/dev/null 2>&1; then
    run_cleanup "pnpm store" "pnpm store prune" "$HOME/.pnpm-store"
  fi

  if command -v gem >/dev/null 2>&1; then
    run_cleanup "RubyGems" "gem cleanup" "$HOME/.gem"
  fi

  if command -v pip >/dev/null 2>&1; then
    run_cleanup "pip cache" "pip cache purge" "$HOME/.cache/pip"
  fi

  if command -v pip3 >/dev/null 2>&1; then
    run_cleanup "pip3 cache" "pip3 cache purge" "$HOME/.cache/pip"
  fi

  if command -v go >/dev/null 2>&1; then
    run_cleanup "Go cache" "go clean -cache -modcache -testcache" "$HOME/go/pkg/mod/cache"
  fi

  if command -v composer >/dev/null 2>&1; then
    run_cleanup "Composer cache" "composer clear-cache" "$HOME/.composer/cache"
  fi
}

#==============================================================================
# Category: Build Tools
#==============================================================================

cleanup_build_tools() {
  [[ $QUIET == false ]] && echo -e "\n${BLUE}Build Tools${NC}"
  [[ $QUIET == false ]] && echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  if command -v bundle >/dev/null 2>&1; then
    run_cleanup "bundler" "bundle clean --force"
  fi

  if command -v ccache >/dev/null 2>&1; then
    run_cleanup "ccache" "ccache -C" "$HOME/.ccache"
  fi
}

#==============================================================================
# Category: Git Repositories
#==============================================================================

cleanup_git_repos() {
  [[ $QUIET == false ]] && echo -e "\n${BLUE}Git Repositories${NC}"
  [[ $QUIET == false ]] && echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  local repos cleaned_count=0
  repos=$(find_git_repos)

  if [[ -z "$repos" ]]; then
    log_progress "Git repositories" "skipped" "None found"
    return 0
  fi

  local git_cmd
  if [[ $AGGRESSIVE_GIT == true ]]; then
    git_cmd="git gc --aggressive --prune=now"
  elif [[ $PRUNE_GIT == true ]]; then
    git_cmd="git gc --prune=now"
  else
    git_cmd="git gc --auto"
  fi

  while IFS= read -r repo; do
    local repo_name
    repo_name=$(basename "$repo")

    if run_cleanup "$repo_name" "(cd '$repo' && $git_cmd)" "$repo/.git" "$GIT_GC_TIMEOUT"; then
      ((cleaned_count++))
    fi
  done <<< "$repos"

  local total_repos
  total_repos=$(echo "$repos" | wc -l | tr -d ' ')
  [[ $QUIET == false ]] && log_info "Found $total_repos repositories, cleaned $cleaned_count"
}

#==============================================================================
# Category: Docker/Podman
#==============================================================================

cleanup_docker() {
  [[ $QUIET == false ]] && echo -e "\n${BLUE}Docker/Podman${NC}"
  [[ $QUIET == false ]] && echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  if command -v docker >/dev/null 2>&1; then
    local docker_cmd
    if [[ $VERY_AGGRESSIVE == true ]]; then
      if [[ $NON_INTERACTIVE == false ]]; then
        log_warning "This will remove ALL unused Docker images AND volumes"
        log_warning "⚠  DATA LOSS RISK: Volumes may contain database data"
      fi
      docker_cmd="docker system prune -a --volumes -f"
    elif [[ $AGGRESSIVE == true ]]; then
      docker_cmd="docker system prune -a -f"
    else
      docker_cmd="docker system prune -f"
    fi

    local requires_confirm="false"
    if [[ $VERY_AGGRESSIVE == true ]] || [[ $AGGRESSIVE == true ]]; then
      requires_confirm="true"
    fi

    run_cleanup "Docker system" "$docker_cmd" "" "$DOCKER_TIMEOUT" "$requires_confirm"
  fi

  if command -v podman >/dev/null 2>&1; then
    local podman_cmd
    if [[ $VERY_AGGRESSIVE == true ]]; then
      podman_cmd="podman system prune -a --volumes -f"
    elif [[ $AGGRESSIVE == true ]]; then
      podman_cmd="podman system prune -a -f"
    else
      podman_cmd="podman system prune -f"
    fi

    run_cleanup "Podman system" "$podman_cmd" "" "$DOCKER_TIMEOUT"
  fi
}

#==============================================================================
# Category: System Caches
#==============================================================================

cleanup_system_caches() {
  [[ $QUIET == false ]] && echo -e "\n${BLUE}System Caches${NC}"
  [[ $QUIET == false ]] && echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  if [[ "$IS_MACOS" == "true" ]]; then
    if [[ $SYSTEM_CACHES == true ]]; then
      run_cleanup "Thumbnail cache" "rm -rf ~/Library/Caches/com.apple.iconservices.store" "$HOME/Library/Caches/com.apple.iconservices.store"
      run_cleanup "Font cache" "sudo atsutil databases -remove"
    else
      skip_with_estimate "Thumbnail cache" "$THUMBNAIL_CACHE_ESTIMATE" "use --system-caches"
      skip_with_estimate "Font cache" "$FONT_CACHE_ESTIMATE" "use --system-caches"
    fi
  fi
}

#==============================================================================
# Category: Xcode (macOS)
#==============================================================================

cleanup_xcode() {
  if [[ "$IS_MACOS" != "true" ]]; then
    return 0
  fi

  if ! xcode-select -p >/dev/null 2>&1; then
    return 0
  fi

  [[ $QUIET == false ]] && echo -e "\n${BLUE}Xcode (macOS)${NC}"
  [[ $QUIET == false ]] && echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  run_cleanup "Simulators" "xcrun simctl delete unavailable"
  run_cleanup "Derived data" "rm -rf ~/Library/Developer/Xcode/DerivedData/*" "$HOME/Library/Developer/Xcode/DerivedData"
  run_cleanup "Archives" "rm -rf ~/Library/Developer/Xcode/Archives/*" "$HOME/Library/Developer/Xcode/Archives"
}

#==============================================================================
# Category: Shopify
#==============================================================================

cleanup_shopify() {
  [[ $QUIET == false ]] && echo -e "\n${BLUE}Shopify${NC}"
  [[ $QUIET == false ]] && echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  if command -v dev >/dev/null 2>&1; then
    # Check if dev cleanup command exists
    if dev help 2>&1 | grep -q cleanup; then
      run_cleanup "dev" "dev cleanup"
    else
      log_progress "dev" "skipped" "cleanup command not available"
    fi
  fi

  if command -v spin >/dev/null 2>&1; then
    if spin help 2>&1 | grep -q cleanup; then
      run_cleanup "spin" "spin cleanup"
    else
      log_progress "spin" "skipped" "cleanup command not available"
    fi
  fi
}

#==============================================================================
# Main Orchestration
#==============================================================================

show_help() {
  cat << EOF
Disk Space Cleanup Utility v$VERSION

Safely cleans developer tool caches and temporary files

USAGE:
  $SCRIPT_NAME [OPTIONS]

OPTIONS:
  -h, --help              Show this help message
  -V, --version           Show version
  -n, --dry-run           Show what would be cleaned without executing
  -y, --yes               Non-interactive mode (safe operations only)
  -q, --quiet             Minimal output
  -v, --verbose           Detailed output

AGGRESSION LEVELS:
  --aggressive            More thorough cleanup (all unused Docker images)
  --very-aggressive       Most thorough (includes Docker volumes - WARNING)

GIT OPTIONS:
  --prune-git             Prune git repos (gc --prune=now)
  --aggressive-git        Aggressive git gc (slow on large repos)

SCOPE OPTIONS:
  --system-caches         Include system caches (requires sudo)
  --detailed-space        Measure per-tool space savings (slower)
  --only=CATEGORIES       Only run specific categories (comma-separated)
                          Categories: packages,languages,build,git,docker,system,xcode,shopify
  --exclude=CATEGORIES    Exclude specific categories

ENVIRONMENT VARIABLES:
  CLEANUP_GIT_GC_TIMEOUT=300              Git gc timeout (seconds)
  CLEANUP_DOCKER_TIMEOUT=300              Docker cleanup timeout (seconds)
  CLEANUP_BREW_TIMEOUT=600                Homebrew cleanup timeout (seconds)
  CLEANUP_DEFAULT_TIMEOUT=120             Other operations timeout (seconds)
  CLEANUP_GIT_MAX_DEPTH=3                 Max depth for git repo search
  CLEANUP_GIT_LOCATIONS="..."             Colon-separated git search paths
  CLEANUP_LOG_DIR="\$HOME/.cache/dev-cleanup"  Log directory
  CLEANUP_KEEP_LOGS=10                    Number of log files to keep

EXAMPLES:
  $SCRIPT_NAME                                    # Interactive, safe defaults
  $SCRIPT_NAME --yes                              # Non-interactive, safe
  $SCRIPT_NAME --yes --aggressive                 # Non-interactive, aggressive
  $SCRIPT_NAME --dry-run                          # Preview what would be cleaned
  $SCRIPT_NAME --only=languages,docker            # Only language tools and Docker
  $SCRIPT_NAME --system-caches --detailed-space   # Include system, measure everything

For more information, see: https://github.com/hamishmorgan/.dotfiles
EOF
}

show_version() {
  echo "$SCRIPT_NAME version $VERSION"
}

parse_arguments() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -V|--version)
        show_version
        exit 0
        ;;
      -n|--dry-run)
        DRY_RUN=true
        shift
        ;;
      -y|--yes)
        NON_INTERACTIVE=true
        shift
        ;;
      -q|--quiet)
        QUIET=true
        shift
        ;;
      -v|--verbose)
        VERBOSE=true
        shift
        ;;
      --aggressive)
        AGGRESSIVE=true
        shift
        ;;
      --very-aggressive)
        VERY_AGGRESSIVE=true
        AGGRESSIVE=true
        shift
        ;;
      --prune-git)
        PRUNE_GIT=true
        shift
        ;;
      --aggressive-git)
        AGGRESSIVE_GIT=true
        PRUNE_GIT=true
        shift
        ;;
      --system-caches)
        SYSTEM_CACHES=true
        shift
        ;;
      --detailed-space)
        DETAILED_SPACE=true
        shift
        ;;
      --only=*)
        IFS=',' read -ra ONLY_CATEGORIES <<< "${1#*=}"
        shift
        ;;
      --exclude=*)
        IFS=',' read -ra EXCLUDE_CATEGORIES <<< "${1#*=}"
        shift
        ;;
      *)
        log_error "Unknown option: $1"
        echo "Run '$SCRIPT_NAME --help' for usage information"
        exit 2
        ;;
    esac
  done
}

should_run_category() {
  local category="$1"

  # Check exclusions first
  for excl in "${EXCLUDE_CATEGORIES[@]}"; do
    if [[ "$excl" == "$category" ]]; then
      return 1
    fi
  done

  # If --only specified, check if category is included
  if [[ ${#ONLY_CATEGORIES[@]} -gt 0 ]]; then
    for only in "${ONLY_CATEGORIES[@]}"; do
      if [[ "$only" == "$category" ]]; then
        return 0
      fi
    done
    return 1
  fi

  return 0
}

setup_logging() {
  mkdir -p "$LOG_DIR"

  LOG_FILE="$LOG_DIR/cleanup-$(date +%Y%m%d-%H%M%S).log"

  log_to_file "START cleanup (version $VERSION)"
  log_to_file "Platform: $PLATFORM"
  log_to_file "Options: DRY_RUN=$DRY_RUN NON_INTERACTIVE=$NON_INTERACTIVE AGGRESSIVE=$AGGRESSIVE VERY_AGGRESSIVE=$VERY_AGGRESSIVE"

  # Cleanup old log files
  local log_count
  log_count=$(find "$LOG_DIR" -name "cleanup-*.log" -type f | wc -l | tr -d ' ')
  if ((log_count > KEEP_LOGS)); then
    find "$LOG_DIR" -name "cleanup-*.log" -type f | sort | head -n -"$KEEP_LOGS" | xargs rm -f
  fi
}

main() {
  parse_arguments "$@"

  setup_logging

  # Header
  if [[ $QUIET == false ]]; then
    echo "Disk Space Cleanup Utility v$VERSION"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo
  fi

  # Count operations
  OPERATION_COUNT=$(count_operations)

  # Initial disk usage
  local initial_disk
  initial_disk=$(get_disk_usage)
  if [[ $QUIET == false ]]; then
    log_info "Initial disk usage: ${initial_disk} GB"
    echo
    [[ $DRY_RUN == true ]] && log_warning "DRY RUN MODE - No changes will be made"
    log_info "Scanning for cleanup opportunities..."
  fi
  log_to_file "Initial disk usage: ${initial_disk} GB"

  # Run cleanup categories
  should_run_category "packages" && cleanup_package_managers
  should_run_category "languages" && cleanup_language_tools
  should_run_category "build" && cleanup_build_tools
  should_run_category "git" && cleanup_git_repos
  should_run_category "docker" && cleanup_docker
  should_run_category "system" && cleanup_system_caches
  should_run_category "xcode" && cleanup_xcode
  should_run_category "shopify" && cleanup_shopify

  # Final summary
  if [[ $QUIET == false ]]; then
    echo
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Cleanup Summary"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo
  fi

  # Final disk usage
  local final_disk
  final_disk=$(get_disk_usage)
  local saved_gb=$((initial_disk - final_disk))

  if [[ $DETAILED_SPACE == true ]] && [[ $TOTAL_SAVED_KB -gt 0 ]]; then
    log_success "Total space reclaimed: $(human_readable_size $TOTAL_SAVED_KB)"
  elif [[ $saved_gb -gt 0 ]]; then
    log_success "Disk space freed: ${saved_gb} GB"
  elif [[ $DRY_RUN == true ]]; then
    log_info "Dry run completed - no changes made"
  else
    log_info "Cleanup completed"
  fi

  if [[ $QUIET == false ]]; then
    log_info "Final disk usage: ${final_disk} GB"
    echo
    log_info "Detailed log: $LOG_FILE"
  fi

  log_to_file "Final disk usage: ${final_disk} GB"
  log_to_file "Total saved: $(human_readable_size $TOTAL_SAVED_KB)"
  log_to_file "END cleanup"

  return 0
}

# Handle interrupts gracefully
trap 'echo; log_warning "Interrupted by user"; log_to_file "INTERRUPTED"; exit 130' INT TERM

# Run main only if not being sourced (for testing)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi

