#!/usr/bin/env bash
# Run all BATS test suites using bats' built-in formatter with timing

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TESTS_DIR="$(cd "$SCRIPT_DIR/../tests" && pwd)"

# Check if BATS is available
if ! command -v bats >/dev/null 2>&1; then
    echo "Error: BATS not installed"
    echo ""
    echo "Install BATS:"
    echo "  macOS:  brew install bats-core"
    echo "  Ubuntu: sudo apt-get install bats"
    echo ""
    exit 1
fi

# Determine number of parallel jobs
# Default to CPU count, but cap at 8 to avoid overwhelming the system
# Tests create isolated temp directories, so parallel execution is safe
if command -v sysctl >/dev/null 2>&1; then
    # macOS
    CPU_COUNT=$(sysctl -n hw.ncpu 2>/dev/null || echo "4")
elif command -v nproc >/dev/null 2>&1; then
    # Linux
    CPU_COUNT=$(nproc 2>/dev/null || echo "4")
else
    CPU_COUNT="4"
fi

# Cap at 8 jobs to avoid resource exhaustion
JOBS=$((CPU_COUNT > 8 ? 8 : CPU_COUNT))

# Check if parallel execution is available (requires GNU parallel or rush)
HAS_PARALLEL=false
if command -v parallel >/dev/null 2>&1 || command -v rush >/dev/null 2>&1; then
    HAS_PARALLEL=true
fi

# Build bats command with optimal flags
BATS_ARGS=(
    --formatter pretty
    --timing
    --print-output-on-failure
    --recursive
)

# Enable parallel execution if available
if $HAS_PARALLEL; then
    BATS_ARGS+=(--jobs "$JOBS")
fi

# Run all test suites with timing and automatic failure output
# Flags:
#   --formatter pretty: Use bats' default pretty formatter (better than TAP)
#   --timing: Show timing information for each test
#   --print-output-on-failure: Automatically show output when tests fail
#   --recursive: Include tests in subdirectories
#   --jobs: Run tests in parallel (if parallel binary available)
bats "${BATS_ARGS[@]}" \
    "$TESTS_DIR/regression" \
    "$TESTS_DIR/unit" \
    "$TESTS_DIR/integration" \
    "$TESTS_DIR/contract"
