#!/bin/bash
# Dotfiles management script

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BACKUP_DIR="$DOTFILES_DIR/backups/dotfiles-backup-$(date +%s)"

# Package definitions
declare -a PACKAGES=("git" "zsh" "tmux" "gh" "gnuplot" "bash")

# Package file mappings (package_name:file1,file2,file3)
declare -A PACKAGE_FILES=(
    ["git"]=".gitconfig,.gitattributes,.gitignore-globals"
    ["zsh"]=".zshrc,.zprofile,.oh-my-zsh"
    ["tmux"]=".tmux.conf"
    ["gh"]=".config/gh"
    ["gnuplot"]=".gnuplot"
    ["bash"]=".bashrc,.bash_profile"
)

# Package display names
declare -A PACKAGE_NAMES=(
    ["git"]="Git"
    ["zsh"]="Zsh"
    ["tmux"]="Tmux"
    ["gh"]="GitHub CLI"
    ["gnuplot"]="GNU Plot"
    ["bash"]="Bash"
)

# Auto-discovery functions for templates and personal configs
# Convention: *.template files are processed to create target files
# Convention: *.personal files are merged with targets based on file type

# Required dependencies per platform
declare -A REQUIRED_DEPS=(
    ["common"]="stow git"
    ["optional"]="tmux zsh"
)

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Show usage information
show_usage() {
    echo "Usage: $0 COMMAND [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  install       Install dotfiles using GNU Stow"
    echo "  validate      Validate dotfiles installation"
    echo "  update        Update submodules and reinstall"
    echo "  update-all    Update all packages and configurations"
    echo "  uninstall     Remove dotfiles symlinks"
    echo "  backup        Create backup of existing files"
    echo "  status        Show installation status"
    echo "  clean         Clean up backup directories"
    echo ""
    echo "Options:"
    echo "  -h, --help    Show this help message"
    echo "  -v, --verbose Enable verbose output"
    echo ""
    echo "Examples:"
    echo "  $0 install           # Install dotfiles"
    echo "  $0 validate          # Validate installation"
    echo "  $0 update            # Update and reinstall"
    echo "  $0 update-all        # Update all packages and configurations"
    echo "  $0 status            # Show status"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check dependencies
check_dependencies() {
    log_info "Checking dependencies..."
    
    local missing_deps=()
    local all_deps="${REQUIRED_DEPS[common]} ${REQUIRED_DEPS[optional]}"
    
    for dep in $all_deps; do
        if ! command_exists "$dep"; then
            missing_deps+=("$dep")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing_deps[*]}"
        echo ""
        echo "Install missing dependencies:"
        echo "  Ubuntu/Debian: sudo apt-get install ${missing_deps[*]}"
        echo "  macOS: brew install ${missing_deps[*]}"
        echo "  CentOS/RHEL: sudo yum install ${missing_deps[*]}"
        echo "  Fedora: sudo dnf install ${missing_deps[*]}"
        exit 1
    fi
    
    log_success "All dependencies satisfied"
}

# Detect platform
detect_platform() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "linux"
    else
        echo "unknown"
    fi
}


# Determine merge strategy based on file type
determine_merge_strategy() {
    local target="$1"
    
    case "$target" in
        */.gitconfig*|*.gitconfig)
            echo "git-merge"
            ;;
        */hosts.yml|*/hosts.yaml)
            echo "yaml-replace"
            ;;
        *.yml|*.yaml)
            echo "yaml-append"
            ;;
        *)
            echo "replace"
            ;;
    esac
}

# Create backup of existing files
backup_existing() {
    log_info "Creating backup of existing files..."
    
    # Create backup directory
    mkdir -p "$BACKUP_DIR"
    
    local backed_up=0
    
    # Generate backup list dynamically from PACKAGE_FILES
    for package in "${PACKAGES[@]}"; do
        local files="${PACKAGE_FILES[$package]}"
        IFS=',' read -ra file_array <<< "$files"
        
        for file in "${file_array[@]}"; do
        if [[ -e "$HOME/$file" ]]; then
            log_info "Backing up $file"
            if [[ -d "$HOME/$file" ]]; then
                cp -r "$HOME/$file" "$BACKUP_DIR/" || {
                    log_error "Failed to copy directory $file"
                    return 1
                }
            else
                cp "$HOME/$file" "$BACKUP_DIR/" || {
                    log_error "Failed to copy file $file"
                    return 1
                }
            fi
            # Remove existing file after backup to prevent stow conflicts
            rm -rf "${HOME:?}/$file" || {
                log_error "Failed to remove $file"
                return 1
            }
            ((backed_up++))
        else
            log_info "File $file does not exist, skipping"
        fi
        done
    done
    
    if [[ $backed_up -gt 0 ]]; then
        log_success "Backed up $backed_up files to $BACKUP_DIR"
    else
        log_info "No existing files to backup"
    fi
}

# Initialize submodules
init_submodules() {
    log_info "Initializing git submodules..."
    
    if [[ -f "$DOTFILES_DIR/.gitmodules" ]]; then
        cd "$DOTFILES_DIR"
        git submodule update --init --recursive
        log_success "Submodules initialized"
    else
        log_info "No submodules found"
    fi
}

# Process configuration templates (auto-discovered)
process_templates() {
    log_info "Processing configuration templates..."
    
    set +e  # Temporarily disable exit on error
    local template_count=0
    
    # Process all .template files found in dotfiles directory  
    find "$DOTFILES_DIR" -type f -name "*.template" 2>/dev/null | sort | while read -r template; do
        local target="${template%.template}"
        
        if cp "$template" "$target"; then
            log_info "Created ${target#"$DOTFILES_DIR"/} from template"
            ((template_count++))
        else
            log_error "Failed to copy template: $template"
        fi
    done
    
    set -e  # Re-enable exit on error
    
    # Check if templates were processed
    local created_files
    created_files=$(find "$DOTFILES_DIR" -type f \( -name ".gitconfig" -o -name ".gitconfig.shopify" -o -name "config.yml" -o -name "hosts.yml" \) ! -name "*.template" ! -name "*.personal" 2>/dev/null | wc -l)
    
    if [[ $created_files -gt 0 ]]; then
        log_success "Processed template files"
    else
        log_info "No template files found"
    fi
}

# Merge git config using git-config command
merge_git_config() {
    local source="$1"
    local target="$2"
    local config_lines=()
    
    # Read git config into array first
    mapfile -t config_lines < <(git -c "core.filemode=false" config --file "$source" --list 2>/dev/null)
    
    # Apply each line to target
    for line in "${config_lines[@]}"; do
        local key="${line%%=*}"
        local value="${line#*=}"
        git -c "core.filemode=false" config --file "$target" "$key" "$value"
    done
}

# Merge personal configurations with templates (auto-discovered)
merge_personal_configs() {
    log_info "Merging personal configurations..."
    
    set +e  # Temporarily disable exit on error
    local merge_count=0
    
    # Process all .personal files found in dotfiles directory
    find "$DOTFILES_DIR" -type f -name "*.personal" 2>/dev/null | sort | while read -r personal; do
        [[ ! -f "$personal" ]] && continue
        
        local target="${personal%.personal}"
        local merge_type
        merge_type=$(determine_merge_strategy "$target")
        
        log_info "Merging ${personal#"$DOTFILES_DIR"/} -> ${target#"$DOTFILES_DIR"/} ($merge_type)"
        
        case "$merge_type" in
            git-merge)
                merge_git_config "$personal" "$target"
                ;;
            yaml-append)
                {
                    echo ""
                    echo "# Personal configuration"
                    cat "$personal"
                } >> "$target"
                ;;
            yaml-replace|replace)
                cp "$personal" "$target"
                ;;
            *)
                log_warning "Unknown merge type: $merge_type"
                continue
                ;;
        esac
        
        ((merge_count++))
    done
    
    set -e  # Re-enable exit on error
    
    # Check if personal configs exist
    local personal_count
    personal_count=$(find "$DOTFILES_DIR" -type f -name "*.personal" 2>/dev/null | wc -l)
    
    if [[ $personal_count -gt 0 ]]; then
        log_success "Merged personal configuration files"
    else
        log_info "No personal configuration files found"
    fi
}

# Install dotfiles using Stow
install_dotfiles() {
    log_info "Installing dotfiles using Stow..."
    
    for package in "${PACKAGES[@]}"; do
        if [[ -d "$package" ]]; then
            log_info "Installing package: $package"
            stow -v -R -d "$DOTFILES_DIR" -t "$HOME" "$package"
            log_success "Installed $package"
        else
            log_warning "Package $package not found, skipping"
        fi
    done
}

# Check if file is properly linked
check_symlink() {
    local file="$1"
    local expected_target="$2"
    
    if [[ -L "$HOME/$file" ]]; then
        local target
        target=$(readlink "$HOME/$file")
        if [[ "$target" == *"$expected_target"* ]]; then
            log_success "✓ $file is properly linked to $target"
            return 0
        else
            log_warning "⚠ $file is linked to $target (expected $expected_target)"
            return 1
        fi
    elif [[ -f "$HOME/$file" ]]; then
        log_warning "⚠ $file exists but is not a symlink"
        return 1
    else
        log_error "✗ $file not found"
        return 1
    fi
}

# Generic package validation function
validate_package() {
    local package="$1"
    local display_name="${PACKAGE_NAMES[$package]}"
    local files="${PACKAGE_FILES[$package]}"
    
    log_info "Validating $display_name configuration..."
    
    local errors=0
    IFS=',' read -ra file_array <<< "$files"
    
    for file in "${file_array[@]}"; do
        if ! check_symlink "$file" ".dotfiles/$package"; then
            ((errors++))
        fi
    done
    
    if [[ $errors -eq 0 ]]; then
        log_success "$display_name configuration validated successfully"
        return 0
    else
        log_error "$display_name validation failed with $errors errors"
        return 1
    fi
}

# Get list of backup directories
get_backup_dirs() {
    local backup_dirs=()
    for dir in "$DOTFILES_DIR"/backups/dotfiles-backup-*; do
        if [[ -d "$dir" ]]; then
            backup_dirs+=("$dir")
        fi
    done
    printf '%s\n' "${backup_dirs[@]}"
}

# Show installation status
show_status() {
    log_info "Dotfiles installation status:"
    echo ""
    
    # Generate file list dynamically from PACKAGE_FILES
    for package in "${PACKAGES[@]}"; do
        local files="${PACKAGE_FILES[$package]}"
        IFS=',' read -ra file_array <<< "$files"
        
        for file in "${file_array[@]}"; do
            if [[ -L "$HOME/$file" ]]; then
                local target
                target=$(readlink "$HOME/$file")
                echo -e "  ${GREEN}✓${NC} $file -> $target"
            elif [[ -e "$HOME/$file" ]]; then
                echo -e "  ${YELLOW}⚠${NC} $file (exists but not a symlink)"
            else
                echo -e "  ${RED}✗${NC} $file (not found)"
            fi
        done
    done
    
    echo ""
    log_info "Backup directories:"
    local backup_dirs=()
    mapfile -t backup_dirs < <(get_backup_dirs)
    
    if [[ ${#backup_dirs[@]} -gt 0 ]]; then
        for dir in "${backup_dirs[@]}"; do
            echo "  $(basename "$dir") ($(du -sh "$dir" | cut -f1))"
        done
    else
        echo "  No backup directories found"
    fi
}

# Clean up backup directories
clean_backups() {
    log_info "Cleaning up backup directories..."
    
    local backup_dirs=()
    mapfile -t backup_dirs < <(get_backup_dirs)
    
    if [[ ${#backup_dirs[@]} -gt 0 ]]; then
        echo "Found backup directories:"
        for dir in "${backup_dirs[@]}"; do
            echo "  $(basename "$dir") ($(du -sh "$dir" | cut -f1))"
        done
        echo ""
        read -p "Delete all backup directories? (y/N): " -n 1 -r
        echo ""
        
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            for dir in "${backup_dirs[@]}"; do
                rm -rf "$dir"
            done
            log_success "Backup directories removed"
        else
            log_info "Backup cleanup cancelled"
        fi
    else
        log_info "No backup directories found"
    fi
}

# Uninstall dotfiles
uninstall_dotfiles() {
    log_info "Uninstalling dotfiles..."
    
    for package in "${PACKAGES[@]}"; do
        if [[ -d "$package" ]]; then
            log_info "Uninstalling package: $package"
            stow -v -D -d "$DOTFILES_DIR" -t "$HOME" "$package"
            log_success "Uninstalled $package"
        fi
    done
    
    log_success "Dotfiles uninstalled"
}

# Main command handlers
cmd_install() {
    log_info "Starting dotfiles installation..."
    
    log_info "Step 1: Backing up existing files..."
    set +e  # Temporarily disable exit on error for backup
    backup_existing
    local backup_exit_code=$?
    set -e  # Re-enable exit on error
    if [[ $backup_exit_code -ne 0 ]]; then
        log_error "Backup failed with exit code $backup_exit_code"
        return 1
    fi
    
    log_info "Step 2: Running installation pipeline..."
    run_installation_pipeline
    
    log_success "Installation completed successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. Restart your terminal or run: source ~/.zshrc"
    echo "  2. Set zsh as default shell: chsh -s \$(which zsh)"
    echo "  3. Validate installation: $0 validate"
}

cmd_validate() {
    log_info "Validating dotfiles installation..."
    
    local errors=0
    
    for package in "${PACKAGES[@]}"; do
        validate_package "$package" || ((errors++))
    done
    
    echo ""
    if [[ $errors -eq 0 ]]; then
        log_success "All validations passed!"
        return 0
    else
        log_error "Validation failed with $errors errors"
        return 1
    fi
}

# Update gitignore globals from gitignore.io
update_gitignore() {
    log_info "Updating .gitignore-globals from toptal.com..."
    
    local types="linux,osx,windows"
    local url="https://www.toptal.com/developers/gitignore/api/$types"
    local gitignore_file="$DOTFILES_DIR/git/.gitignore-globals"
    
    if curl -s "$url" > "$gitignore_file.tmp"; then
        mv "$gitignore_file.tmp" "$gitignore_file"
        log_success "Updated .gitignore-globals with latest patterns"
    else
        rm -f "$gitignore_file.tmp"
        log_error "Failed to download .gitignore-globals"
        return 1
    fi
}

# Update Oh My Zsh
update_oh_my_zsh() {
    log_info "Checking for Oh My Zsh updates..."
    
    if command_exists omz; then
        if omz update; then
            log_success "Oh My Zsh updated successfully"
        else
            log_warning "Oh My Zsh update failed or no updates available"
        fi
    else
        log_warning "Oh My Zsh not available for update"
    fi
}

# Common installation pipeline
run_installation_pipeline() {
    check_dependencies
    init_submodules
    process_templates
    merge_personal_configs
    install_dotfiles
}

cmd_update() {
    log_info "Updating dotfiles..."
    run_installation_pipeline
    log_success "Update completed successfully!"
}

cmd_update_all() {
    log_info "Updating all packages and configurations..."
    
    # Update gitignore globals
    update_gitignore
    
    # Update Oh My Zsh
    update_oh_my_zsh
    
    # Reinstall to pick up any changes
    run_installation_pipeline
    
    log_success "All packages updated successfully!"
}

cmd_status() {
    show_status
}

cmd_backup() {
    backup_existing
}

cmd_clean() {
    clean_backups
}

cmd_uninstall() {
    uninstall_dotfiles
}

# Main script logic
main() {
    # Parse arguments
    local command=""
    local verbose=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            install|validate|update|update-all|status|backup|clean|uninstall)
                if [[ -n "$command" ]]; then
                    log_error "Multiple commands specified"
                    exit 1
                fi
                command="$1"
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
    
    # Default to help if no command specified
    if [[ -z "$command" ]]; then
        show_usage
        exit 0
    fi
    
    # Enable verbose output if requested
    if $verbose; then
        set -x
    fi
    
    # Execute command
    case $command in
        install)
            cmd_install
            ;;
        validate)
            cmd_validate
            ;;
        update)
            cmd_update
            ;;
        update-all)
            cmd_update_all
            ;;
        status)
            cmd_status
            ;;
        backup)
            cmd_backup
            ;;
        clean)
            cmd_clean
            ;;
        uninstall)
            cmd_uninstall
            ;;
        *)
            log_error "Unknown command: $command"
            show_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
