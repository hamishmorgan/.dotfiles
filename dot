#!/usr/bin/env bash
# Dotfiles management script
# Compatible with bash 3.2+ (including macOS default bash)
#
# Bash 3.2 Compatibility Notes:
# - Uses functions instead of associative arrays (bash 4+ feature)
# - Uses while-read loops instead of mapfile (bash 4+ feature)
# - Avoids process substitution where possible for portability
# - All array operations use bash 3.2 compatible syntax

# Verify bash version
if [[ "${BASH_VERSINFO[0]}" -lt 3 || ( "${BASH_VERSINFO[0]}" -eq 3 && "${BASH_VERSINFO[1]}" -lt 2 ) ]]; then
    echo "Error: This script requires bash 3.2 or later"
    echo "Current version: $BASH_VERSION"
    exit 1
fi

# Safer glob handling
shopt -s nullglob      # Empty expansion for non-matching globs
shopt -s extglob       # Extended pattern matching

# Note: Not using 'set -e' for better error handling control
# Errors are explicitly checked and handled with context

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Status symbols
SYMBOL_SUCCESS='✓'
SYMBOL_ERROR='✗'
SYMBOL_WARNING='⚠'
SYMBOL_INFO='∙'

# Configuration
DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PACKAGES_DIR="$DOTFILES_DIR/packages"

# Verbosity level constants (with fun names!)
readonly VERBOSITY_MUTE=-1          # Silent mode (errors only)
readonly VERBOSITY_TACITURN=0       # Normal output (summary + errors/warnings)
readonly VERBOSITY_LOQUACIOUS=1     # Verbose (add package names and progress)
readonly VERBOSITY_GARRULOUS=2      # Very verbose (show every file operation)

# Global variable for validator error output (used by run_validator)
VALIDATOR_ERROR_OUTPUT=""

# Backup retention policy (configurable via environment variables)
readonly MAX_BACKUPS_TO_DISPLAY="${DOTFILES_MAX_BACKUPS_TO_DISPLAY:-5}"     # Status output
readonly MAX_BACKUPS_TO_KEEP="${DOTFILES_MAX_BACKUPS_TO_KEEP:-10}"          # Auto cleanup threshold

# Display limits
readonly RESTORE_DISPLAY_LIMIT="${DOTFILES_RESTORE_DISPLAY_LIMIT:-20}"      # Restore preview

# Timeout values in seconds
readonly GIT_TIMEOUT="${DOTFILES_GIT_TIMEOUT:-60}"                           # Git operations
readonly CURL_TIMEOUT="${DOTFILES_CURL_TIMEOUT:-30}"                         # Curl downloads

# Security
readonly SECRET_FILE_MODE="${DOTFILES_SECRET_FILE_MODE:-600}"                # Secret file permissions

# Output formatting
readonly OUTPUT_PREFIX="${DOTFILES_OUTPUT_PREFIX:-│ }"                       # Indentation character

# Backup paths
readonly BACKUP_DIR_PREFIX="${DOTFILES_BACKUP_DIR_PREFIX:-backups/dotfiles-backup}"
readonly RESTORE_SAFETY_PREFIX="${DOTFILES_RESTORE_SAFETY_PREFIX:-backups/dotfiles-pre-restore}"
BACKUP_DIR="$DOTFILES_DIR/${BACKUP_DIR_PREFIX}-$(date +%s)"

# Unit conversion constants
readonly SECONDS_PER_DAY=86400
readonly KB_TO_MB=1024

# Track installation state for rollback
INSTALLED_PACKAGES=()
INSTALLATION_IN_PROGRESS=false
ROLLBACK_STACK=()

# Add action to rollback stack
add_rollback() {
    local action="$1"
    ROLLBACK_STACK+=("$action")
}

# Execute rollback in reverse order
execute_rollback() {
    if [[ ${#ROLLBACK_STACK[@]} -eq 0 ]]; then
        log_info "Nothing to rollback"
        return 0
    fi

    log_warning "Rolling back installation..."

    # Execute in reverse order (LIFO)
    for ((i=${#ROLLBACK_STACK[@]}-1; i>=0; i--)); do
        log_info "Rollback step: ${ROLLBACK_STACK[i]}"
        eval "${ROLLBACK_STACK[i]}" 2>/dev/null || log_warning "Rollback step failed (non-critical)"
    done

    log_success "Rollback completed"
    return 0
}

# Cleanup handler
cleanup_on_exit() {
    local exit_code=$?

    # Only run cleanup if installation was in progress and failed
    if [[ $INSTALLATION_IN_PROGRESS == true ]] && [[ $exit_code -ne 0 ]]; then
        echo ""
        log_error "Installation interrupted or failed (exit code: $exit_code)"

        if [[ ${#ROLLBACK_STACK[@]} -gt 0 ]]; then
            echo ""
            read -p "Rollback installation? (Y/n): " -n 1 -r
            echo ""

            if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
                execute_rollback
            else
                log_info "Skipping rollback"
                if [[ ${#INSTALLED_PACKAGES[@]} -gt 0 ]]; then
                    log_warning "Partial installation: ${INSTALLED_PACKAGES[*]}"
                    log_info "Run './dot uninstall' to remove manually"
                fi
            fi
        fi
    fi
}

# Interrupt handler
handle_interrupt() {
    echo ""
    log_warning "Installation interrupted by user"
    exit 130
}

# Set up traps
trap cleanup_on_exit EXIT
trap handle_interrupt INT TERM

# Package definitions
# Auto-discovery via manifests replaces static PACKAGES array

# Discover packages by scanning for manifests
discover_packages() {
    local packages=()

    if [[ ! -d "$PACKAGES_DIR" ]]; then
        return 1
    fi

    # Find manifest.toml files only in direct package directories (maxdepth 2)
    # This is fast: only ~11 directories to check
    while IFS= read -r manifest; do
        # Extract package name from path
        local package_dir
        package_dir=$(dirname "$manifest")
        local package
        package=$(basename "$package_dir")

        # Validate manifest exists and is readable
        if [[ -f "$manifest" ]] && [[ -r "$manifest" ]]; then
            packages+=("$package")
        fi
    done < <(find "$PACKAGES_DIR" -maxdepth 2 -name "manifest.toml" -type f 2>/dev/null)

    # Output space-separated list (bash 3.2 compatible)
    # Array expansion creates space-separated output which is what we need
    echo "${packages[@]}"
}

get_packages() {
    # Auto-discovery via manifest scanning
    local discovered
    discovered=$(discover_packages 2>/dev/null)

    if [[ -z "$discovered" ]]; then
        # Error handling - log functions may not be defined yet
        echo "Error: No packages found. Ensure manifests exist in $PACKAGES_DIR/*/manifest.toml" >&2
        return 1
    fi

    # Ensure system package is always first (if present), using simple array filtering
    local packages_array=()
    read -ra packages_array <<< "$discovered"

    # Print 'system' first if present, then the rest, space-separated
    local result=""
    local first=true

    # Add system first if present
    for package in "${packages_array[@]}"; do
        if [[ "$package" == "system" ]]; then
            result="system"
            first=false
            break
        fi
    done

    # Add remaining packages
    for package in "${packages_array[@]}"; do
        if [[ "$package" != "system" ]]; then
            if [[ "$first" == true ]]; then
                result="$package"
                first=false
            else
                result="$result $package"
            fi
        fi
    done

    echo "$result"
}

# Initialize PACKAGES array (auto-discovery via manifests)
# Package discovery is deferred until after argument parsing to allow --help to work
# without requiring packages to exist
PACKAGES=()

# Initialize packages array (called after argument parsing for commands that need packages)
initialize_packages() {
    # Use read to populate array correctly and handle spaces
    # Validate that packages were discovered successfully
    local get_packages_output
    local get_packages_exit_code
    get_packages_output=$(get_packages 2>&1)
    get_packages_exit_code=$?

    if [[ $get_packages_exit_code -ne 0 ]]; then
        echo "Error: Failed to execute package discovery (get_packages command failed). Ensure manifests exist in $PACKAGES_DIR/*/manifest.toml" >&2
        echo "Debug: PACKAGES_DIR=$PACKAGES_DIR" >&2
        echo "Debug: DOTFILES_DIR=$DOTFILES_DIR" >&2
        [[ -n "$get_packages_output" ]] && echo "Debug: get_packages output: $get_packages_output" >&2
        return 1
    fi

    read -ra PACKAGES <<< "$get_packages_output"

    # Validate that PACKAGES array is not empty
    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
        echo "Error: Package discovery succeeded but found no packages. Ensure manifests exist in $PACKAGES_DIR/*/manifest.toml" >&2
        echo "Debug: PACKAGES_DIR=$PACKAGES_DIR" >&2
        echo "Debug: DOTFILES_DIR=$DOTFILES_DIR" >&2
        return 1
    fi

    # Validate that all discovered packages have valid, parseable manifests
    local validation_errors=0
    for package in "${PACKAGES[@]}"; do
        local manifest="$PACKAGES_DIR/$package/manifest.toml"

        # Check manifest file exists
        if [[ ! -f "$manifest" ]]; then
            echo "Error: Package '$package' missing manifest file: $manifest" >&2
            ((validation_errors++))
            continue
        fi

        # Check manifest is readable
        if [[ ! -r "$manifest" ]]; then
            echo "Error: Package '$package' manifest not readable: $manifest" >&2
            ((validation_errors++))
            continue
        fi

        # Validate manifest can be parsed (load with error reporting)
        if ! load_package_manifest "$package" false 2>&1 | grep -q "Error"; then
            : # Manifest loaded successfully
        else
            # Capture and display the actual error
            local error_output
            error_output=$(load_package_manifest "$package" false 2>&1)
            echo "Error: Package '$package' has invalid manifest:" >&2
            echo "$error_output" >&2
            ((validation_errors++))
        fi
    done

    if [[ $validation_errors -gt 0 ]]; then
        echo "" >&2
        echo "Error: Found $validation_errors package(s) with missing or invalid manifests" >&2
        echo "All packages require a valid manifest.toml file" >&2
        return 1
    fi

    return 0
}

# Helper function to remove quotes and whitespace from strings
# Used for cleaning file paths extracted from TOML arrays
# Note: This removes ALL quotes, including quotes that might be part of the value
# For TOML values, use get_toml_value() which handles quotes correctly
trim_quotes_and_whitespace() {
    local input="$1"
    # Remove leading/trailing whitespace, single quotes, and double quotes
    echo "$input" | sed 's/^["'\''[:space:]]*//; s/["'\''[:space:]]*$//'
}

# Get package files (manifest-only)
# Get files/directories for each package (for status display)
# Note: Returns macOS-specific paths for cross-platform packages (cursor).
# This function is used for display/validation purposes only.
# Actual stowing logic handles platform differences via get_platform_ignore().
get_package_files() {
    local package="$1"

    if ! load_package_manifest "$package"; then
        log_error "Package '$package' missing manifest: $PACKAGES_DIR/$package/manifest.toml"
        log_info "Create a minimal manifest:"
        log_info "  files = [\"file1\", \"file2\"]"
        return 1
    fi

    echo "$PACKAGE_FILES"
}

# Expand wildcards in file patterns against package directory
# Input: comma-separated file patterns (may contain wildcards)
# Output: comma-separated actual files (wildcards expanded)
expand_file_patterns() {
    local package="$1"
    local patterns="$2"
    local expanded_files=()

    IFS=',' read -ra pattern_array <<< "$patterns"

    for pattern in "${pattern_array[@]}"; do
        # Trim whitespace
        pattern=$(echo "$pattern" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')

        # Check if pattern contains wildcards
        if [[ "$pattern" == *\** ]]; then
            # Expand wildcard against package directory
            local package_dir="$PACKAGES_DIR/$package"
            local matches=()

            # Use find to match the pattern
            shopt -s nullglob
            while IFS= read -r -d '' file; do
                # Convert absolute path to relative path from package dir
                local rel_path="${file#"$package_dir"/}"
                matches+=("$rel_path")
            done < <(find "$package_dir" -path "$package_dir/$pattern" -print0 2>/dev/null)
            shopt -u nullglob

            # Add all matches to expanded_files
            if [[ ${#matches[@]} -gt 0 ]]; then
                expanded_files+=("${matches[@]}")
            fi
        else
            # No wildcard, use pattern as-is
            expanded_files+=("$pattern")
        fi
    done

    # Output as comma-separated list
    local IFS=','
    echo "${expanded_files[*]}"
}

# Get package description (manifest-only)
get_package_description() {
    local package="$1"

    if ! load_package_manifest "$package"; then
        log_error "Package '$package' missing manifest: $PACKAGES_DIR/$package/manifest.toml"
        echo ""  # Return empty string on error
        return 1
    fi

    echo "$PACKAGE_DESCRIPTION"
}

# Get installation method (manifest-only)
get_package_method() {
    local package="$1"

    if ! load_package_manifest "$package"; then
        log_error "Package '$package' missing manifest: $PACKAGES_DIR/$package/manifest.toml"
        echo "stow"  # Return default on error
        return 1
    fi

    echo "$PACKAGE_METHOD"
}

# Get required dependencies (bash 3.2 compatible - no associative arrays)
get_required_deps() {
    local type="$1"
    case "$type" in
        common)   echo "stow git" ;;
        *)        echo "" ;;
    esac
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Package Manifest Functions (TOML parsing)
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Helper function to escape regex special characters in section names
escape_regex_special_chars() {
    local input="$1"
    echo "$input" | sed 's/\[/\\[/g; s/\]/\\]/g; s/\./\\./g; s/\*/\\*/g; s/\+/\\+/g; s/\?/\\?/g; s/\^/\\^/g; s/\$/\\$/g'
}

# Get TOML value from section (empty string for top-level)
# Checks for key existence to distinguish missing vs empty
get_toml_value() {
    local file="$1"
    local section="$2"  # Empty string for top-level
    local key="$3"

    if [[ ! -f "$file" ]]; then
        return 1
    fi

    # Handle top-level vs section
    if [[ -z "$section" ]]; then
        # Top-level key - search before first [ section
        local section_content
        section_content=$(sed '/^\[/,$d' "$file")
    else
        # Escape regex special characters in section name for safe matching
        local escaped_section
        escaped_section=$(escape_regex_special_chars "$section")

        # Extract section content
        # Only remove last line if it starts with [ (next section), not if it's content
        section_content=$(sed -n "/\[$escaped_section\]/,/^\[/p" "$file" | sed -e '1d' -e '/^\[/,$d')
    fi

    # Check if key exists at all (even if empty)
    # Escape regex special characters in key for safe matching
    local escaped_key
    escaped_key=$(escape_regex_special_chars "$key")
    local key_exists
    key_exists=$(echo "$section_content" | grep -c "^$escaped_key\s*=" 2>/dev/null || echo "0")
    # Remove any whitespace/newlines from grep output
    key_exists="${key_exists//[[:space:]]/}"

    if [[ "$key_exists" -eq 0 ]]; then
        return 1  # Key doesn't exist - use default
    fi

    # Extract key value, strip comments and trim whitespace
    # Use escaped key for safe pattern matching (already computed above)
    local value_line
    value_line=$(echo "$section_content" | \
        grep "^$escaped_key\s*=" | \
        sed 's/#.*$//; s/^\s*//; s/\s*$//' | \
        head -1)

    if [[ -z "$value_line" ]]; then
        return 1
    fi

    # Extract value (handle quoted and unquoted)
    local value
    # Extract everything after first = sign, then trim leading whitespace
    value="${value_line#*=}"
    # Trim leading whitespace (handles spaces, tabs, etc.)
    value="${value#"${value%%[![:space:]]*}"}"

    # Remove quotes if present (handles both single and double quotes)
    # Note: This does not handle escaped quotes within values - document limitation if needed
    if [[ "$value" =~ ^[\"'].*[\"']$ ]]; then
        # Remove leading and trailing quotes (both single and double)
        # Use separate checks for each quote type to avoid shellcheck issues
        if [[ "$value" =~ ^\".*\"$ ]]; then
            value="${value#\"}"
            value="${value%\"}"
        elif [[ "$value" =~ ^\'.*\'$ ]]; then
            value="${value#\'}"
            value="${value%\'}"
        fi
    fi

    # Return empty string if key exists but value is empty (explicit empty)
    # Caller checks return code: 0 = key exists (even if empty), 1 = key missing
    echo "$value"
    return 0
}

# Get TOML array (supports single-line and multi-line arrays)
# Uses balanced bracket matching to handle nested brackets correctly
# Supports top-level keys (empty section string)
get_toml_array() {
    local file="$1"
    local section="$2"  # Empty string for top-level
    local key="$3"

    if [[ ! -f "$file" ]]; then
        return 1
    fi

    # Handle top-level vs section
    if [[ -z "$section" ]]; then
        # Top-level key - search before first [ section
        local section_content
        section_content=$(sed '/^\[/,$d' "$file")
    else
        # Extract section content
        local escaped_section
        escaped_section=$(escape_regex_special_chars "$section")
        # Get content from section header to next section or end of file
        # Remove section header line itself, keep content lines
        section_content=$(sed -n "/\[$escaped_section\]/,/^\[/p" "$file" | sed -e '1d' -e '/^\[/,$d')
    fi

    # Find array declaration (key = [...] or key = [ ... ])
    # Escape key for safe regex matching
    local escaped_key
    escaped_key=$(escape_regex_special_chars "$key")
    local array_start_line
    array_start_line=$(echo "$section_content" | grep -n "^$escaped_key\s*=" | cut -d: -f1 | head -1)

    if [[ -z "$array_start_line" ]]; then
        return 1
    fi

    # Extract lines starting from array declaration
    # Stop at closing bracket to avoid processing subsequent lines
    local array_lines
    array_lines=$(echo "$section_content" | sed -n "${array_start_line},\$p" | sed "/\]/q")

    # Parse array using balanced bracket matching
    local result_value=""
    local in_quotes=false
    local quote_char=""
    local bracket_depth=0
    local array_started=false
    local current_element=""
    local line_num=0

    # Process character by character (bash 3.2 compatible)
    while IFS= read -r line; do
        ((line_num++))

        # Skip comment lines
        if [[ "$line" =~ ^[[:space:]]*# ]]; then
            continue
        fi

        # Process each character (inline comments handled within loop to respect quotes)
        for ((i=0; i<${#line}; i++)); do
            local char="${line:$i:1}"

            # If we see a '#' outside of quotes, treat as comment and break
            if [[ "$char" == "#" && "$in_quotes" == false ]]; then
                break
            fi

            case "$char" in
                '[')
                    if [[ "$in_quotes" == false ]]; then
                        if [[ "$array_started" == false ]]; then
                            array_started=true
                        fi
                        ((bracket_depth++))
                    else
                        current_element="$current_element$char"
                    fi
                    ;;
                ']')
                    if [[ "$in_quotes" == false ]]; then
                        ((bracket_depth--))
                        if [[ $bracket_depth -eq 0 && "$array_started" == true ]]; then
                            # End of array
                            if [[ -n "$current_element" ]]; then
                                current_element=$(echo "$current_element" | sed 's/^\s*//; s/\s*$//')
                                if [[ -n "$current_element" ]]; then
                                    if [[ -n "$result_value" ]]; then
                                        result_value="$result_value,$current_element"
                                    else
                                        result_value="$current_element"
                                    fi
                                fi
                            fi
                            # Remove quotes and return
                            # Use parameter expansion to avoid sed character class issues
                            result_value="${result_value//\"/}"
                            result_value="${result_value//\'/}"
                            # Remove spaces around commas using parameter expansion (bash 3.2 compatible)
                            local previous_value
                            while true; do
                                previous_value="$result_value"
                                result_value="${result_value// ,/,}"
                                result_value="${result_value//, /,}"
                                # Stop if no changes were made
                                [[ "$result_value" == "$previous_value" ]] && break
                            done
                            echo "$result_value"
                            return 0
                        fi
                    else
                        current_element="$current_element$char"
                    fi
                    ;;
                '"'|"'")
                    if [[ "$in_quotes" == false ]]; then
                        in_quotes=true
                        quote_char="$char"
                        current_element="$current_element$char"
                    elif [[ "$char" == "$quote_char" ]]; then
                        # Closing quote - add to current_element BEFORE toggling in_quotes
                        current_element="$current_element$char"
                        in_quotes=false
                        quote_char=""
                    else
                        # Different quote type (single vs double) - treat as regular character
                        current_element="$current_element$char"
                    fi
                    ;;
                ',')
                    if [[ "$in_quotes" == false && "$array_started" == true && $bracket_depth -eq 1 ]]; then
                        # Comma separator at array level
                        current_element=$(echo "$current_element" | sed 's/^\s*//; s/\s*$//')
                        if [[ -n "$current_element" ]]; then
                            if [[ -n "$result_value" ]]; then
                                result_value="$result_value,$current_element"
                            else
                                result_value="$current_element"
                            fi
                        fi
                        current_element=""
                    else
                        current_element="$current_element$char"
                    fi
                    ;;
                *)
                    # Add character if we're inside the array (started) OR if we're inside quotes
                    # This ensures characters inside quoted strings are captured even before array_started is set
                    if [[ "$array_started" == true || "$in_quotes" == true ]]; then
                        current_element="$current_element$char"
                    fi
                    ;;
            esac
        done

        # Add newline if in quotes (for multi-line strings)
        if [[ "$in_quotes" == true ]]; then
            current_element="$current_element "
        fi
    done <<< "$array_lines"

    # Array not closed properly
    if [[ $bracket_depth -ne 0 ]]; then
        log_error "Unbalanced brackets in array (manifest: $file, section: $section, key: $key)"
        return 1
    fi

    # Handle final element if array was properly closed
    # (in case array ends without trailing comma: [ "a", "b" ])
    if [[ -n "$current_element" ]]; then
        current_element=$(echo "$current_element" | sed 's/^\s*//; s/\s*$//')
        if [[ -n "$current_element" ]]; then
            if [[ -n "$result_value" ]]; then
                result_value="$result_value,$current_element"
            else
                result_value="$current_element"
            fi
        fi
    fi

    # Output result (even if empty array [])
    if [[ -n "$result_value" ]]; then
        # Use parameter expansion to avoid sed character class issues
        result_value="${result_value//\"/}"
        result_value="${result_value//\'/}"
        # Remove spaces around commas using parameter expansion (bash 3.2 compatible)
        local previous_value
        while true; do
            previous_value="$result_value"
            result_value="${result_value// ,/,}"
            result_value="${result_value//, /,}"
            # Stop if no changes were made
            [[ "$result_value" == "$previous_value" ]] && break
        done
        echo "$result_value"
    else
        echo ""  # Empty array
    fi
    return 0
}

# Apply platform-specific target override from manifest
# Bash 3.2 compatible
apply_platform_target_override() {
    local manifest="$1"
    local platform="$2"

    if [[ "$platform" == "linux" ]]; then
        local linux_target
        linux_target=$(get_toml_value "$manifest" "linux" "target")
        if [[ -n "$linux_target" ]]; then
            # Expand ~ to $HOME if present
            if [[ "$linux_target" == ~* ]]; then
                linux_target="${linux_target/#\~/$HOME}"
            fi
            PACKAGE_TARGET="$linux_target"
        fi
    elif [[ "$platform" == "macos" ]]; then
        local macos_target
        macos_target=$(get_toml_value "$manifest" "macos" "target")
        if [[ -n "$macos_target" ]]; then
            # Expand ~ to $HOME if present
            if [[ "$macos_target" == ~* ]]; then
                macos_target="${macos_target/#\~/$HOME}"
            fi
            PACKAGE_TARGET="$macos_target"
        fi
    fi
}

# Load package manifest (manifest.toml)
# Sets global variables: PACKAGE_NAME, PACKAGE_DESCRIPTION, PACKAGE_METHOD, PACKAGE_TARGET, PACKAGE_FILES
load_package_manifest() {
    local package="$1"
    local silent="${2:-false}"  # Optional: suppress error logging (for optional checks)
    local manifest="$PACKAGES_DIR/$package/manifest.toml"

    if [[ ! -f "$manifest" ]]; then
        [[ "$silent" != "true" ]] && log_error "Package '$package' missing manifest: $manifest" >&2
        return 1  # No manifest
    fi

    # Extract values from top-level keys (store results to avoid double calls)
    local name_value
    name_value=$(get_toml_value "$manifest" "" "name" 2>&1)
    local toml_exit=$?
    if [[ $toml_exit -ne 0 ]] && [[ -n "$name_value" ]]; then
        # get_toml_value failed with error output
        [[ "$silent" != "true" ]] && log_error "Failed to parse 'name' in $manifest: $name_value" >&2
        return 1
    fi
    if [[ -n "$name_value" ]]; then
        PACKAGE_NAME="$name_value"
    else
        PACKAGE_NAME="$package"  # Default: directory name
    fi

    local description_value
    description_value=$(get_toml_value "$manifest" "" "description" 2>&1)
    # Description is optional, ignore errors
    if [[ -n "$description_value" ]] && ! echo "$description_value" | grep -q "error\|Error\|ERROR"; then
        PACKAGE_DESCRIPTION="$description_value"
    else
        PACKAGE_DESCRIPTION=""  # Default: empty
    fi

    local method_value
    method_value=$(get_toml_value "$manifest" "" "method" 2>&1)
    # Method is optional
    if [[ -n "$method_value" ]] && ! echo "$method_value" | grep -q "error\|Error\|ERROR"; then
        PACKAGE_METHOD="$method_value"
    else
        PACKAGE_METHOD="stow"  # Default: stow
    fi

    local target_value
    target_value=$(get_toml_value "$manifest" "" "target" 2>&1)
    # Target is optional
    if [[ -n "$target_value" ]] && ! echo "$target_value" | grep -q "error\|Error\|ERROR"; then
        PACKAGE_TARGET="$target_value"
        # Expand ~ to $HOME if present
        if [[ "$PACKAGE_TARGET" == ~* ]]; then
            PACKAGE_TARGET="${PACKAGE_TARGET/#\~/$HOME}"
        fi
    else
        PACKAGE_TARGET="$HOME"  # Default: $HOME
    fi

    # Extract files array (top-level) - REQUIRED
    local files_result
    local files_error
    files_error=$(get_toml_array "$manifest" "" "files" 2>&1)
    toml_exit=$?
    if [[ $toml_exit -ne 0 ]]; then
        if [[ "$silent" != "true" ]]; then
            if [[ -n "$files_error" ]]; then
                log_error "Failed to parse 'files' array in $manifest: $files_error" >&2
            else
                log_error "Manifest missing required 'files' array: $manifest" >&2
            fi
        fi
        return 1
    fi
    PACKAGE_FILES="$files_error"

    # Check for platform-specific target overrides
    local platform
    platform=$(detect_platform)  # Function that returns "linux", "macos", or "unknown"
    apply_platform_target_override "$manifest" "$platform"
    # Unknown platform → uses default target (no override)

    # Files array is required - convert to comma-separated for compatibility
    if [[ -z "$PACKAGE_FILES" ]]; then
        [[ "$silent" != "true" ]] && log_error "Manifest has empty 'files' array: $manifest" >&2
        return 1  # Invalid manifest - files required
    fi

    return 0
}

# Get TOML inline table (parses { command = "...", args = [...] })
# Returns: "command|arg1,arg2,arg3" format (pipe-separated, args comma-separated)
# Bash 3.2 compatible character-by-character parsing
get_toml_inline_table() {
    local file="$1"
    local section="$2"  # Empty string for top-level
    local key="$3"

    if [[ ! -f "$file" ]]; then
        return 1
    fi

    # Extract section content
    local section_content
    if [[ -z "$section" ]]; then
        section_content=$(sed '/^\[/,$d' "$file")
    else
        local escaped_section
        escaped_section=$(escape_regex_special_chars "$section")
        # Extract from [section] to next [ or end of file
        section_content=$(sed -n "/\[$escaped_section\]/,/^\[/p" "$file")
        # Remove first line ([section]) and last line if it starts with [ (next section)
        section_content=$(echo "$section_content" | sed '1d')
        if echo "$section_content" | grep -q '^\['; then
            section_content=$(echo "$section_content" | sed '$d')
        fi
    fi

    # Find inline table declaration (key = { ... })
    # Handle quoted keys like ".gitconfig" - match with quotes in the file
    local table_start_line
    # The key comes in as ".gitconfig" (without quotes from get_validation_patterns)
    # Match it with quotes in the file: "key" = { ... }
    # Escape special regex chars in the key for grep, then wrap in quotes
    local escaped_key
    escaped_key=$(escape_regex_special_chars "$key")
    # Try with quotes first (most common case)
    table_start_line=$(echo "$section_content" | grep -n "^\"$escaped_key\"\s*=" | cut -d: -f1 | head -1)
    # If not found, try without quotes (for unquoted keys)
    if [[ -z "$table_start_line" ]]; then
        table_start_line=$(echo "$section_content" | grep -n "^$escaped_key\s*=" | cut -d: -f1 | head -1)
    fi

    if [[ -z "$table_start_line" ]]; then
        return 1
    fi

    # Extract line with inline table
    local table_line
    table_line=$(echo "$section_content" | sed -n "${table_start_line}p" | sed 's/#.*$//')
    # Extract everything after the first = sign (key = { ... })
    # Use awk to split on first = and get everything after it
    table_line=$(echo "$table_line" | awk -F'=' '{if (NF>1) {s=""; for(i=2;i<=NF;i++) {if(i>2) s=s"="; s=s$i}; print s}}')
    # Trim leading/trailing whitespace (handle any whitespace characters)
    table_line=$(echo "$table_line" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')

    # Handle multi-line inline tables (they shouldn't exist in our simplified TOML, but handle just in case)
    # Check if table closes on same line
    local open_braces
    open_braces=$(echo "$table_line" | grep -o '{' | wc -l | tr -d ' ')
    local close_braces
    close_braces=$(echo "$table_line" | grep -o '}' | wc -l | tr -d ' ')

    if [[ -z "$open_braces" ]]; then
        open_braces=0
    fi
    if [[ -z "$close_braces" ]]; then
        close_braces=0
    fi

    # If braces don't match, read more lines (shouldn't happen in our simplified TOML)
    if [[ $open_braces -gt $close_braces ]]; then
        local line_count=$((table_start_line + 1))
        while IFS= read -r next_line; do
            table_line="$table_line$next_line"
            open_braces=$(echo "$table_line" | grep -o '{' | wc -l | tr -d ' ')
            close_braces=$(echo "$table_line" | grep -o '}' | wc -l | tr -d ' ')
            if [[ -z "$open_braces" ]]; then
                open_braces=0
            fi
            if [[ -z "$close_braces" ]]; then
                close_braces=0
            fi
            if [[ $open_braces -eq $close_braces ]]; then
                break
            fi
            ((line_count++))
        done < <(echo "$section_content" | sed -n "$((table_start_line + 1)),\$p")
    fi

    # Parse inline table: { command = "value", args = [...] }
    local in_quotes=false
    local quote_char=""
    local bracket_depth=0
    local in_table=false
    local current_field=""
    local field_name=""
    local command_value=""
    local args_array=""
    local in_array=false
    local array_bracket_depth=0

    # Process character by character
    for ((i=0; i<${#table_line}; i++)); do
        local char="${table_line:$i:1}"

        case "$char" in
            '{')
                if [[ "$in_quotes" == false ]]; then
                    in_table=true
                    ((bracket_depth++))
                    # Don't add { to current_field - it's not part of field name/value
                else
                    current_field="$current_field$char"
                fi
                ;;
            '}')
                if [[ "$in_quotes" == false ]]; then
                    ((bracket_depth--))
                    if [[ $bracket_depth -eq 0 ]]; then
                        # End of table - process last field (if any)
                        # Don't add } to current_field - it's not part of field value
                        if [[ -n "$field_name" && -n "$current_field" ]]; then
                            local trimmed_field_name
                            trimmed_field_name=$(echo "$field_name" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
                            if [[ "$trimmed_field_name" == "command" ]]; then
                                command_value=$(echo "$current_field" | sed 's/^\s*//; s/\s*$//' | sed 's/^["'\'']//; s/["'\'']$//')
                            elif [[ "$trimmed_field_name" == "args" ]]; then
                                args_array=$(echo "$current_field" | sed 's/^\s*//; s/\s*$//')
                            fi
                        elif [[ -z "$field_name" && -n "$current_field" ]]; then
                            # Handle case where last field wasn't processed yet (no trailing comma)
                            # Try to determine field type from context - if current_field looks like an array, it's args
                            if echo "$current_field" | grep -q '^\['; then
                                args_array=$(echo "$current_field" | sed 's/^\s*//; s/\s*$//')
                            fi
                        fi
                        break
                    else
                        current_field="$current_field$char"
                    fi
                else
                    current_field="$current_field$char"
                fi
                ;;
            '[')
                if [[ "$in_quotes" == false && "$in_table" == true ]]; then
                    in_array=true
                    ((array_bracket_depth++))
                fi
                current_field="$current_field$char"
                ;;
            ']')
                if [[ "$in_quotes" == false && "$in_array" == true ]]; then
                    ((array_bracket_depth--))
                    if [[ $array_bracket_depth -eq 0 ]]; then
                        in_array=false
                    fi
                fi
                current_field="$current_field$char"
                ;;
            '=')
                if [[ "$in_quotes" == false && "$in_table" == true && "$in_array" == false ]]; then
                    # Field name before '=' (only if not inside array)
                    field_name=$(echo "$current_field" | sed 's/^\s*//; s/\s*$//')
                    current_field=""
                else
                    current_field="$current_field$char"
                fi
                ;;
            ',')
                if [[ "$in_quotes" == false && "$in_table" == true && "$in_array" == false ]]; then
                    # Field separator (only if not inside array)
                            local trimmed_field_name
                            trimmed_field_name=$(echo "$field_name" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
                            if [[ "$trimmed_field_name" == "command" ]]; then
                                command_value=$(echo "$current_field" | sed 's/^\s*//; s/\s*$//' | sed 's/^["'\'']//; s/["'\'']$//')
                            elif [[ "$trimmed_field_name" == "args" ]]; then
                                args_array=$(echo "$current_field" | sed 's/^\s*//; s/\s*$//')
                            fi
                            field_name=""
                            current_field=""
                else
                    current_field="$current_field$char"
                fi
                ;;
            '"'|"'")
                if [[ "$in_quotes" == false ]]; then
                    in_quotes=true
                    quote_char="$char"
                elif [[ "$char" == "$quote_char" ]]; then
                    in_quotes=false
                    quote_char=""
                fi
                current_field="$current_field$char"
                ;;
            *)
                current_field="$current_field$char"
                ;;
        esac
    done

    # Parse args array if present
    if [[ -n "$args_array" ]]; then
        # Extract array content (remove brackets)
        local args_content
        args_content=$(echo "$args_array" | sed 's/^\[//; s/\]$//')

        # Parse array elements (handle quoted strings)
        local args_list=""
        local in_quotes=false
        local quote_char=""
        local current_arg=""

        for ((i=0; i<${#args_content}; i++)); do
            local char="${args_content:$i:1}"

            case "$char" in
                ',')
                    if [[ "$in_quotes" == false ]]; then
                        # Arg separator
                        current_arg=$(echo "$current_arg" | sed 's/^\s*//; s/\s*$//' | sed 's/^["'\'']//; s/["'\'']$//')
                        if [[ -n "$args_list" ]]; then
                            args_list="$args_list,$current_arg"
                        else
                            args_list="$current_arg"
                        fi
                        current_arg=""
                    else
                        current_arg="$current_arg$char"
                    fi
                    ;;
                '"'|"'")
                    if [[ "$in_quotes" == false ]]; then
                        in_quotes=true
                        quote_char="$char"
                    elif [[ "$char" == "$quote_char" ]]; then
                        in_quotes=false
                        quote_char=""
                    fi
                    current_arg="$current_arg$char"
                    ;;
                *)
                    current_arg="$current_arg$char"
                    ;;
            esac
        done

        # Add last arg
        if [[ -n "$current_arg" ]]; then
            current_arg=$(echo "$current_arg" | sed 's/^\s*//; s/\s*$//' | sed 's/^["'\'']//; s/["'\'']$//')
            if [[ -n "$args_list" ]]; then
                args_list="$args_list,$current_arg"
            else
                args_list="$current_arg"
            fi
        fi

        args_array="$args_list"
    fi

    if [[ -z "$command_value" ]]; then
        return 1
    fi

    # Return format: "command|arg1,arg2,arg3"
    if [[ -n "$args_array" ]]; then
        echo "$command_value|$args_array"
    else
        echo "$command_value|"
    fi
    return 0
}

# Get validation entry for a specific key (file path/pattern)
# Returns: "command|arg1,arg2,arg3" format
get_validation_entry() {
    local manifest="$1"
    local key="$2"

    if [[ ! -f "$manifest" ]]; then
        return 1
    fi

    # Use get_toml_inline_table to parse validation entry
    get_toml_inline_table "$manifest" "validation" "$key"
}

# Get update command from [update] section in manifest
# Returns: "command|arg1,arg2,arg3" format (pipe-separated, args comma-separated)
# Returns empty string if no [update] section exists
get_toml_update_command() {
    local manifest="$1"

    if [[ ! -f "$manifest" ]]; then
        return 1
    fi

    # Extract [update] section content
    local escaped_section
    escaped_section=$(escape_regex_special_chars "update")
    local section_content
    section_content=$(sed -n "/\[$escaped_section\]/,/^\[/p" "$manifest")
    # Remove first line ([update]) and last line if it starts with [ (next section)
    section_content=$(echo "$section_content" | sed -e '1d' -e '/^\[/,$d')

    if [[ -z "$section_content" ]]; then
        return 1
    fi

    # Look for command = "..." and args = [...]
    local command_value=""
    local args_array=""

    # Parse command field
    local command_line
    command_line=$(echo "$section_content" | grep -E '^\s*command\s*=' | head -1)
    if [[ -n "$command_line" ]]; then
        command_value=$(echo "$command_line" | sed 's/.*=\s*//' | sed 's/^["'\'']//; s/["'\'']$//' | sed 's/^\s*//; s/\s*$//')
    fi

    # Parse args array (handle single-line and multi-line)
    if args_array=$(get_toml_array "$manifest" "update" "args" 2>/dev/null); then
        # args_array is already comma-separated from get_toml_array
        :
    else
        # Fallback: try to extract from single line
        local args_line
        args_line=$(echo "$section_content" | grep -E '^\s*args\s*=' | head -1)
        if [[ -n "$args_line" ]] && echo "$args_line" | grep -q '\[.*\]'; then
            # Single-line array
            args_array=$(echo "$args_line" | sed 's/.*=\s*\[//; s/\]\s*$//' | sed 's/^["'\'']//g; s/["'\'']\s*$//g' | sed 's/["'\'']\s*,\s*["'\'']/,/g' | sed 's/^\s*//; s/\s*$//')
        fi
    fi

    if [[ -z "$command_value" ]]; then
        return 1
    fi

    # Return in format: "command|arg1,arg2,arg3"
    if [[ -n "$args_array" ]]; then
        echo "$command_value|$args_array"
    else
        echo "$command_value|"
    fi

    return 0
}

# Get all validation pattern keys from [validation] section
# Returns: One pattern per line
get_validation_patterns() {
    local manifest="$1"

    if [[ ! -f "$manifest" ]]; then
        return 1
    fi

    # Extract [validation] section
    local escaped_section
    escaped_section=$(escape_regex_special_chars "validation")
    local section_content
    section_content=$(sed -n "/\[$escaped_section\]/,/^\[/p" "$manifest" | sed -e '1d' -e '/^\[/,$d' | sed 's/#.*$//')

    # Check if validation section exists
    if [[ -z "$section_content" ]]; then
        return 1  # No validation section
    fi

    # Extract all keys (lines matching "key" = { ... })
    # Handle both quoted and unquoted keys
    local patterns
    patterns=$(echo "$section_content" | grep -E '^\s*"[^"]+"\s*=' | sed 's/^\s*"\([^"]*\)".*/\1/')

    # Return failure if no patterns found
    if [[ -z "$patterns" ]]; then
        return 1
    fi

    echo "$patterns"
}

# Get validator for a file (exact match first, then glob patterns)
# Returns: "command|arg1,arg2,arg3" format via stdout
# Bash 3.2 compatible (no nameref)
get_validator_for_file() {
    local file="$1"
    local package="$2"

    local manifest="$PACKAGES_DIR/$package/manifest.toml"

    if [[ ! -f "$manifest" ]]; then
        return 1
    fi

    # First try exact match
    local cmd
    cmd=$(get_validation_entry "$manifest" "$file")
    if [[ -n "$cmd" ]]; then
        echo "$cmd"
        return 0
    fi

    # Then try glob patterns (in order from manifest)
    local patterns
    patterns=$(get_validation_patterns "$manifest")

    if [[ -z "$patterns" ]]; then
        return 1
    fi

    while IFS= read -r pattern; do
        [[ -z "$pattern" ]] && continue

        # Unquoted pattern enables bash glob matching (intentional for wildcard support)
        # Patterns come from trusted manifest files (part of repository), so glob expansion is safe
        # shellcheck disable=SC2053
        if [[ "$file" == $pattern ]]; then
            cmd=$(get_validation_entry "$manifest" "$pattern")
            if [[ -n "$cmd" ]]; then
                echo "$cmd"
                return 0
            fi
        fi
    done <<< "$patterns"

    return 1
}

# Run validator with command and args array
# CRITICAL: Uses array expansion to preserve spaces/quotes correctly
run_validator() {
    local command="$1"
    shift
    local args=("$@")

    # Resolve relative paths (e.g., "dev/validate-tmux") relative to DOTFILES_DIR
    if [[ "$command" == */* ]] && [[ ! "$command" == /* ]]; then
        # Relative path - resolve relative to DOTFILES_DIR
        local resolved_command="$DOTFILES_DIR/$command"
        if [[ -f "$resolved_command" ]] && [[ -x "$resolved_command" ]]; then
            command="$resolved_command"
        elif [[ ! -f "$command" ]]; then
            # Command doesn't exist as relative path either
            local file_path=""
            # Find file path in args (usually last arg or contains "file")
            for arg in "${args[@]}"; do
                if [[ -f "$arg" ]]; then
                    file_path="$arg"
                    break
                fi
            done
            if [[ -z "$file_path" ]]; then
                # Bash 3.2 compatible: get last element of array
                local last_idx=$((${#args[@]} - 1))
                file_path="${args[$last_idx]}"
            fi
            log_warning "$command not found, skipping validation for ${file_path#"$HOME"/}"
            return 0  # Continue, not an error
        fi
    fi

    # Check if command exists
    if ! command_exists "$command"; then
        local file_path=""
        # Find file path in args (usually last arg or contains "file")
        for arg in "${args[@]}"; do
            if [[ -f "$arg" ]]; then
                file_path="$arg"
                break
            fi
        done
        if [[ -z "$file_path" ]]; then
            # Bash 3.2 compatible: get last element of array
            local last_idx=$((${#args[@]} - 1))
            file_path="${args[$last_idx]}"
        fi
        log_warning "$command not installed, skipping validation for ${file_path#"$HOME"/}"
        return 0  # Continue, not an error
    fi

    # Execute validator (array expansion preserves spaces/quotes)
    # Capture both stdout and stderr for error reporting
    local validator_output
    validator_output=$("$command" "${args[@]}" 2>&1)
    local validator_exit=$?

    if [[ $validator_exit -eq 0 ]]; then
        return 0
    else
        # Return error output via global variable for caller to access
        VALIDATOR_ERROR_OUTPUT="$validator_output"
        return 1
    fi
}

# Run package update command
# Similar to run_validator but for update commands
run_package_update() {
    local command="$1"
    shift
    local args=("$@")

    # Resolve relative paths (e.g., "dev/update-something") relative to DOTFILES_DIR
    if [[ "$command" == */* ]] && [[ ! "$command" == /* ]]; then
        # Relative path - resolve relative to DOTFILES_DIR
        local resolved_command="$DOTFILES_DIR/$command"
        if [[ -f "$resolved_command" ]] && [[ -x "$resolved_command" ]]; then
            command="$resolved_command"
        fi
    fi

    # Check if command exists
    if ! command_exists "$command"; then
        log_warning "$command not installed, skipping update"
        return 0  # Continue, not an error
    fi

    # Execute update command (array expansion preserves spaces/quotes)
    # Output goes to stdout/stderr (not suppressed like validators)
    if "$command" "${args[@]}" 2>&1 | prefix_output "│ "; then
        return 0
    else
        return 1
    fi
}

# Validate manifest syntax
validate_manifest_syntax() {
    local manifest="$1"
    local errors=0

    # Check file exists
    if [[ ! -f "$manifest" ]]; then
        log_error "Manifest not found: $manifest"
        return 1
    fi

    # Check for files array (top-level)
    if ! grep -q "^files\s*=" "$manifest"; then
        log_error "Manifest missing 'files' field: $manifest"
        ((errors++))
    fi

    # Basic TOML syntax check (look for invalid patterns)
    if grep -q "^[^#\[\s].*[^=]=[^=]" "$manifest"; then
        # Check for invalid lines (not comments, sections, or key=value)
        log_warning "Manifest may have syntax issues: $manifest"
    fi

    return $errors
}

# Validate manifest semantics (file existence, method validity)
validate_manifest_semantic() {
    local package="$1"
    local manifest="$PACKAGES_DIR/$package/manifest.toml"
    local errors=0

    if ! load_package_manifest "$package"; then
        return 1
    fi

    # Validate method
    case "$PACKAGE_METHOD" in
        stow|copy-sync|template|script)
            # Valid method
            ;;
        *)
            log_error "Invalid method '$PACKAGE_METHOD' in manifest: $manifest"
            ((errors++))
            ;;
    esac

    # Validate files exist
    IFS=',' read -ra files <<< "$PACKAGE_FILES"
    for file in "${files[@]}"; do
        local file_path="$PACKAGES_DIR/$package/$file"

        # Check for path traversal
        if [[ "$file" == *".."* ]] || [[ "$file" == "/"* ]]; then
            log_error "Invalid file path (security): $file"
            ((errors++))
            continue
        fi

        # Check file exists
        if [[ ! -e "$file_path" ]]; then
            log_error "File listed in manifest but not found: $file (expected: $file_path)"
            ((errors++))
        fi
    done

    return $errors
}

# Auto-discovery functions for templates and secret configs
# Convention: *.template files are processed to create target files
# Convention: *.secret files are merged with targets based on file type

# Discover all template files and output template:target pairs
discover_templates() {
    find "$PACKAGES_DIR" -type f -name "*.template" 2>/dev/null | while read -r template; do
        local target="${template%.template}"
        local package_dir
        package_dir=$(dirname "$template")
        local rel_path="${target#"$package_dir"/}"

        echo "$template:$rel_path"
    done | sort
}

# Discover all secret config files
discover_secret_configs() {
    find "$PACKAGES_DIR" -type f -name "*.secret" 2>/dev/null | sort
}

# Logging functions
log_info() {
    echo -e "${BLUE}${SYMBOL_INFO}${NC} $1"
}

log_success() {
    echo -e "${GREEN}${SYMBOL_SUCCESS}${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}${SYMBOL_WARNING}${NC} $1" >&2
}

log_error() {
    echo -e "${RED}${SYMBOL_ERROR}${NC} $1" >&2
}

# Prefix subcommand output for clarity with smart colorization
# Colors lines based on content patterns (errors, warnings, info)
prefix_output() {
    local prefix="${1:-$OUTPUT_PREFIX}"
    while IFS= read -r line; do
        # Skip harmless stow BUG warnings about absolute path mismatches
        if [[ "$line" =~ "BUG in find_stowed_path? Absolute/relative mismatch" ]]; then
            continue
        fi

        # Pattern matching for line classification
        if [[ "$line" =~ ^[[:space:]]*(ERROR|error|Error|FAIL|fail|failed|Failed|cannot|Cannot|unable|Unable|fatal|Fatal|FATAL) ]] || \
           [[ "$line" =~ (error:|failed:|fatal:) ]]; then
            # Error patterns - red
            echo -e "${RED}${prefix}${line}${NC}"
        elif [[ "$line" =~ ^[[:space:]]*(WARN|warn|Warn|WARNING|warning|Warning|BUG) ]] || \
             [[ "$line" =~ (warning:|warn:) ]]; then
            # Warning patterns - yellow
            echo -e "${YELLOW}${prefix}${line}${NC}"
        elif [[ "$line" =~ ^[[:space:]]*(SUCCESS|success|Success|OK|ok|Ok|DONE|done|Done|✓|✔) ]] || \
             [[ "$line" =~ (success:|complete:|completed:) ]]; then
            # Success patterns - green
            echo -e "${GREEN}${prefix}${line}${NC}"
        else
            # Info/normal output - blue (subtle)
            echo -e "${BLUE}${prefix}${NC}${line}"
        fi
    done
}

# Show usage information
show_usage() {
    echo "Usage: $0 COMMAND [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  install       Install dotfiles using GNU Stow"
    echo "  status        Show installation status and recent backups"
    echo "  health        Run comprehensive diagnostics"
    echo "  update        Update configurations and reinstall"
    echo "  diff          Preview changes before applying"
    echo "  uninstall     Remove dotfiles symlinks"
    echo "  backup        Create backup of existing files"
    echo "  backups       List all available backups with details"
    echo "  restore       Restore from a specific backup"
    echo "  clean         Remove old backup files"
    echo "  packages      List all available packages"
    echo "  enable        Enable (install) a specific package"
    echo "  disable       Disable (uninstall) a specific package"
    echo "  security      Run security audit on dotfiles"
    echo "  sync PACKAGE   Sync package files to system (for copy-sync packages)"
    echo "  pull PACKAGE   Pull package files from system (for copy-sync packages)"
    echo "  completion SHELL   Output shell completion script (bash, zsh, or fish)"
    echo ""
    echo "Options:"
    echo "  -h, --help           Show this help message"
    echo "  -q, --quiet          Quiet mode (errors only, level -1)"
    echo "  -v, --verbose        Verbose output (level 1)"
    echo "  -vv                  Very verbose output (level 2)"
    echo ""
    echo "Verbosity Levels:"
    echo "  $VERBOSITY_MUTE (-q, --quiet)       Quiet mode (errors only)"
    echo "  $VERBOSITY_TACITURN (default)       Normal output (summary + errors/warnings)"
    echo "  $VERBOSITY_LOQUACIOUS (-v, --verbose) Verbose (add package names and progress)"
    echo "  $VERBOSITY_GARRULOUS (-vv)          Very verbose (show every file operation)"
    echo ""
    echo "  Note: Last verbosity flag wins if multiple are specified"
    echo ""
    echo "Examples:"
    echo "  $0 install                # Install with summary only"
    echo "  $0 install -q             # Install silently (errors only)"
    echo "  $0 install -v             # Install showing packages"
    echo "  $0 install -vv            # Install showing every file link"
    echo "  $0 health                 # Diagnostics table"
    echo "  $0 health -v              # Detailed diagnostics"
    echo "  $0 update                 # Update with summary"
    echo "  $0 update -vv             # Update with all details"
    echo ""
    echo "Quick reference:"
    echo "  status   = Quick overview (symlinks + backups)"
    echo "  health   = Table format (use -v for detailed output)"
    echo "  install  = Clean summary (use -v/-vv for more detail)"
    echo "  update   = Clean summary (use -v/-vv for more detail)"
    echo ""
    echo "Shell Integration:"
    echo "  # In .bashrc or .zshrc:"
    echo "  source <($0 completion bash)  # for bash"
    echo "  source <($0 completion zsh)   # for zsh"
    echo "  source (\$0 completion fish)  # for fish"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Portable timeout function (works on Linux and macOS)
# Uses GNU timeout if available, otherwise falls back to Perl
portable_timeout() {
    local duration="$1"
    shift

    if command_exists timeout; then
        timeout "$duration" "$@"
    elif command_exists perl; then
        # Perl-based timeout (portable, available on macOS)
        perl -e 'alarm shift; exec @ARGV' "$duration" "$@"
    else
        # No timeout available, run command normally
        "$@"
    fi
}

# Check dependencies
# Get minimum version for a tool (bash 3.2 compatible - no associative arrays)
get_min_version() {
    local tool="$1"
    case "$tool" in
        git)  echo "2.0.0" ;;
        stow) echo "2.3" ;;
        *)    echo "" ;;  # No minimum version requirement
    esac
}

# Compare semantic versions (returns 0 if $1 >= $2)
# Works on both Linux (GNU sort) and macOS (BSD sort)
version_ge() {
    local v1="$1"
    local v2="$2"

    # Try GNU sort -V (Linux)
    if printf '%s\n%s\n' "$v2" "$v1" | sort -V -C 2>/dev/null; then
        return 0
    elif [[ $? -eq 2 ]]; then
        # Exit code 2 means sort -V not supported, try gsort (Homebrew)
        if command -v gsort >/dev/null 2>&1; then
            printf '%s\n%s\n' "$v2" "$v1" | gsort -V -C
            return $?
        fi

        # Fall back to bash-native comparison
        _version_ge_fallback "$v1" "$v2"
        return $?
    else
        # Exit code 1 means sort -V worked but comparison failed
        return 1
    fi
}

# Fallback version comparison for systems without sort -V (bash 3.2 compatible)
# Returns 0 if $1 >= $2
_version_ge_fallback() {
    local v1="$1"
    local v2="$2"

    # Split versions by dots (IFS localized to read command)
    IFS=. read -ra ver1 <<< "$v1"
    IFS=. read -ra ver2 <<< "$v2"

    # Compare each component
    local max_len=${#ver1[@]}
    [[ ${#ver2[@]} -gt $max_len ]] && max_len=${#ver2[@]}

    local i
    for ((i=0; i<max_len; i++)); do
        local num1="${ver1[i]:-0}"
        local num2="${ver2[i]:-0}"

        # Strip letters from end (e.g., "3a" -> "3")
        num1="${num1%%[a-z]*}"
        num2="${num2%%[a-z]*}"

        # Compare numerically
        if ((10#$num1 > 10#$num2)); then
            return 0
        elif ((10#$num1 < 10#$num2)); then
            return 1
        fi
    done

    # All components equal
    return 0
}

# Check specific tool version and return current version on stdout
# Returns: 0 if version >= minimum, 1 otherwise
check_tool_version() {
    local tool="$1"
    local min_version="$2"
    local current_version=""

    case "$tool" in
        git)
            current_version=$(git --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?' | head -n 1)
            ;;
        stow)
            current_version=$(stow --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?' | head -n 1)
            ;;
    esac

    # Output current version for caller
    echo "$current_version"

    if [[ -z "$current_version" ]]; then
        return 1  # Could not determine version
    fi

    if version_ge "$current_version" "$min_version"; then
        return 0  # Version is sufficient
    else
        return 1  # Version is too old
    fi
}

# Check dependencies with version requirements
# Usage: check_dependencies [verbosity]
#   verbosity 0 (default): Only show errors
#   verbosity 1 (-v): Show each tool being checked
#   verbosity 2 (-vv): Show version details for each tool
check_dependencies() {
    local verbosity="${1:-$VERBOSITY_TACITURN}"

    log_info "Checking dependencies..."

    local missing_deps=()
    local outdated_deps=()
    local satisfied_deps=()
    local common_deps
    common_deps="$(get_required_deps common)"

    for dep in $common_deps; do
        if ! command_exists "$dep"; then
            missing_deps+=("$dep")
            [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]] && log_error "Checking $dep... not found"
        else
            # Check version if minimum is specified
            local min_version
            min_version=$(get_min_version "$dep")

            if [[ -n "$min_version" ]]; then
                # Capture version and check status in one call (efficiency fix from Copilot)
                local actual_version
                actual_version=$(check_tool_version "$dep" "$min_version" 2>&1)
                local check_status=$?

                if [[ $check_status -eq 0 ]]; then
                    # Version is sufficient
                    satisfied_deps+=("$dep:$actual_version:$min_version")
                    if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
                        log_success "Checking $dep... ${actual_version} (>= ${min_version})"
                    elif [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
                        log_success "Checking $dep... ${actual_version}"
                    fi
                elif [[ -n "$actual_version" ]]; then
                    # Version was determined but is too old
                    outdated_deps+=("$dep (${actual_version} < ${min_version})")
                    if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
                        log_warning "Checking $dep... version too old (${actual_version} < ${min_version})"
                    fi
                else
                    # Could not determine version - treat as outdated
                    outdated_deps+=("$dep (unknown < ${min_version})")
                    if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
                        log_warning "Checking $dep... unable to determine version"
                    fi
                fi
            else
                # No version requirement
                satisfied_deps+=("$dep:present")
                if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
                    log_success "Checking $dep... present (no version requirement)"
                elif [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
                    log_success "Checking $dep... present"
                fi
            fi
        fi
    done

    local has_errors=false

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        has_errors=true
        log_error "Missing required dependencies: ${missing_deps[*]}"
        echo ""
        echo "Install missing dependencies:"
        echo "  Ubuntu/Debian: sudo apt-get install ${missing_deps[*]}"
        echo "  macOS: brew install ${missing_deps[*]}"
        echo "  CentOS/RHEL: sudo yum install ${missing_deps[*]}"
        echo "  Fedora: sudo dnf install ${missing_deps[*]}"
        echo ""
    fi

    if [[ ${#outdated_deps[@]} -gt 0 ]]; then
        has_errors=true
        log_error "Outdated dependencies detected:"
        for outdated in "${outdated_deps[@]}"; do
            echo "  ${SYMBOL_ERROR} $outdated"
        done
        echo ""
        echo "Update outdated dependencies:"
        echo "  Ubuntu/Debian: sudo apt-get update && sudo apt-get upgrade"
        echo "  macOS: brew upgrade"
        echo "  CentOS/RHEL: sudo yum update"
        echo "  Fedora: sudo dnf upgrade"
        echo ""
    fi

    if [[ "$has_errors" == true ]]; then
        return 1
    fi

    log_success "All dependencies satisfied"

    # Show summary at verbosity 1+
    if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]] && [[ ${#satisfied_deps[@]} -gt 0 ]]; then
        log_info "Total: ${#satisfied_deps[@]} dependencies satisfied"
    fi

    return 0
}

# Detect platform
detect_platform() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "linux"
    else
        echo "unknown"
    fi
}


# Determine merge strategy based on file type
determine_merge_strategy() {
    local target="$1"

    case "$target" in
        */.gitconfig*|*.gitconfig)
            echo "git-merge"
            ;;
        */hosts.yml|*/hosts.yaml)
            echo "yaml-replace"
            ;;
        *.yml|*.yaml)
            echo "yaml-append"
            ;;
        *)
            echo "replace"
            ;;
    esac
}

# Create backup of existing files
backup_existing() {
    log_info "Creating backup of existing files..."

    # Create backup directory
    if ! mkdir -p "$BACKUP_DIR"; then
        log_error "Failed to create backup directory: $BACKUP_DIR"
        suggest_fixes "backup" "$BACKUP_DIR"
        return 1
    fi

    local backed_up=0

    # Generate backup list dynamically from package definitions
    for package in "${PACKAGES[@]}"; do
        local files
        files=$(get_package_files "$package")
        # Expand wildcards in file patterns
        files=$(expand_file_patterns "$package" "$files")
        IFS=',' read -ra file_array <<< "$files"

        for file in "${file_array[@]}"; do
        if [[ -e "$HOME/$file" ]]; then
            log_info "Backing up $file"
            if [[ -d "$HOME/$file" ]]; then
                if ! cp -r "$HOME/$file" "$BACKUP_DIR/" 2>/dev/null; then
                    log_error "Failed to copy directory $file"
                    suggest_fixes "backup" "$HOME/$file"
                    return 1
                fi
            else
                if ! cp "$HOME/$file" "$BACKUP_DIR/" 2>/dev/null; then
                    log_error "Failed to copy file $file"
                    suggest_fixes "backup" "$HOME/$file"
                    return 1
                fi
            fi
            # Remove existing file after backup to prevent stow conflicts
            if ! rm -rf "${HOME:?}/$file" 2>/dev/null; then
                log_error "Failed to remove $file"
                suggest_fixes "backup" "$HOME/$file"
                return 1
            fi
            ((backed_up++))
        else
            log_info "File $file does not exist, skipping"
        fi
        done
    done

    if [[ $backed_up -gt 0 ]]; then
        log_success "Backed up $backed_up files to $BACKUP_DIR"
    else
        log_info "No existing files to backup"
    fi

    return 0
}

# Initialize submodules
init_submodules() {
    log_info "Initializing git submodules..."

    if [[ ! -f "$DOTFILES_DIR/.gitmodules" ]]; then
        log_info "No submodules found"
        return 0
    fi

    cd "$DOTFILES_DIR" || {
        log_error "Failed to change to dotfiles directory: $DOTFILES_DIR"
        return 1
    }

    # Use portable timeout
    if ! portable_timeout "$GIT_TIMEOUT" git submodule update --init --recursive 2>&1 | prefix_output "│ "; then
        log_error "Failed to initialize git submodules (timeout or git error)"
        log_info "Try running: cd $DOTFILES_DIR && git submodule update --init --recursive"
        return 1
    fi

    log_success "Submodules initialized"
    return 0
}

# Process configuration templates (auto-discovered)
process_templates() {
    log_info "Processing configuration templates..."

    local template_count=0
    local failed_count=0

    # Process all .template files found in dotfiles directory
    while IFS= read -r template; do
        [[ -z "$template" ]] && continue

        local target="${template%.template}"

        if [[ ! -f "$template" ]]; then
            log_warning "Template not found: ${template#"$DOTFILES_DIR"/}"
            ((failed_count++))
            continue
        fi

        if cp "$template" "$target" 2>/dev/null; then
            log_info "Created ${target#"$DOTFILES_DIR"/} from template"
            ((template_count++))
        else
            log_error "Failed to copy template: ${template#"$DOTFILES_DIR"/}"
            suggest_fixes "template" "$template"
            ((failed_count++))
        fi
    done < <(find "$PACKAGES_DIR" -type f -name "*.template" 2>/dev/null | sort)

    if [[ $template_count -eq 0 ]] && [[ $failed_count -eq 0 ]]; then
        log_info "No template files found"
    elif [[ $template_count -gt 0 ]]; then
        log_success "Processed $template_count template(s)"
    fi

    if [[ $failed_count -gt 0 ]]; then
        log_error "Failed to process $failed_count template(s)"
        return 1
    fi

    return 0
}

# Merge git config using git-config command
merge_git_config() {
    local source="$1"
    local target="$2"

    # Read git config output (avoid process substitution hang)
    local config_output
    config_output=$(git -c "core.filemode=false" config --file "$source" --list 2>&1) || {
        log_error "Failed to read git config from: ${source#"$DOTFILES_DIR"/}"
        log_error "Git error: $config_output"
        suggest_fixes "git-config" "$source"
        return 1
    }

    # Apply each line to target
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local key="${line%%=*}"
        local value="${line#*=}"

        if ! git -c "core.filemode=false" config --file "$target" "$key" "$value" 2>/dev/null; then
            log_warning "Failed to set $key in ${target#"$DOTFILES_DIR"/}"
        fi
    done <<< "$config_output"

    return 0
}

# Secure permissions on secret config file
secure_secret_file() {
    local secret="$1"

    if [[ ! -f "$secret" ]]; then
        return 0
    fi

    if ! chmod "$SECRET_FILE_MODE" "$secret" 2>/dev/null; then
        log_warning "Failed to set secure permissions on ${secret#"$DOTFILES_DIR"/}"
        return 1
    fi

    return 0
}

# Merge secret configurations with templates (auto-discovered)
# NOTE: Legacy function - retained for backward compatibility but dormant
# (no .secret files exist after consolidation to .local pattern)
merge_secret_configs() {
    log_info "Merging secret configurations..."

    local merge_count=0
    local failed_count=0

    # Process all .secret files found in dotfiles directory
    while IFS= read -r secret; do
        [[ -z "$secret" ]] && continue
        [[ ! -f "$secret" ]] && continue

        # Set secure permissions on secret file unconditionally
        secure_secret_file "$secret"

        local target="${secret%.secret}"

        if [[ ! -f "$target" ]]; then
            log_warning "Target file not found for ${secret#"$DOTFILES_DIR"/}, skipping"
            continue
        fi

        local merge_type
        merge_type=$(determine_merge_strategy "$target")

        log_info "Merging ${secret#"$DOTFILES_DIR"/} -> ${target#"$DOTFILES_DIR"/} ($merge_type)"

        case "$merge_type" in
            git-merge)
                if merge_git_config "$secret" "$target"; then
                    ((merge_count++))
                else
                    log_error "Failed to merge git config from ${secret#"$DOTFILES_DIR"/}"
                    ((failed_count++))
                fi
                ;;
            yaml-append)
                if {
                    echo ""
                    echo "# Secret configuration"
                    cat "$secret"
                } >> "$target" 2>/dev/null; then
                    ((merge_count++))
                else
                    log_error "Failed to append secret config to ${target#"$DOTFILES_DIR"/}"
                    ((failed_count++))
                fi
                ;;
            yaml-replace|replace)
                if cp "$secret" "$target" 2>/dev/null; then
                    ((merge_count++))
                else
                    log_error "Failed to copy ${secret#"$DOTFILES_DIR"/} to ${target#"$DOTFILES_DIR"/}"
                    ((failed_count++))
                fi
                ;;
            *)
                log_warning "Unknown merge type: $merge_type for ${secret#"$DOTFILES_DIR"/}"
                ((failed_count++))
                ;;
        esac
    done < <(find "$DOTFILES_DIR" -type f -name "*.secret" 2>/dev/null | sort)

    if [[ $merge_count -eq 0 ]] && [[ $failed_count -eq 0 ]]; then
        log_info "No secret configuration files found"
    elif [[ $merge_count -gt 0 ]]; then
        log_success "Merged $merge_count secret config(s)"
    fi

    if [[ $failed_count -gt 0 ]]; then
        log_error "Failed to merge $failed_count secret config(s)"
        return 1
    fi

    return 0
}

# Install dotfiles using Stow with rollback support
install_dotfiles() {
    local verbosity="${1:-$VERBOSITY_TACITURN}"

    # Set stow flags based on verbosity level
    local stow_flags="--restow --dir=$PACKAGES_DIR --target=$HOME"
    if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
        stow_flags="--verbose $stow_flags"
    fi

    # Only show header in verbose mode
    if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
        log_info "Installing dotfiles using Stow..."
    fi

    for package in "${PACKAGES[@]}"; do
        if [[ ! -d "$PACKAGES_DIR/$package" ]]; then
            log_warning "Package directory not found: $package, skipping"
            continue
        fi

        # Show package name at verbosity 1+
        if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
            log_info "Installing package: $package"
        fi

        # Add rollback action before installing
        add_rollback "stow --verbose --delete --dir='$PACKAGES_DIR' --target='$HOME' '$package' 2>/dev/null || true"

        # Run stow with appropriate output handling
        local stow_output
        local stow_result

        # shellcheck disable=SC2086
        if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
            # Level 2: Show all stow file operations
            # Try --restow first, but if it fails due to conflicts, try --adopt
            if stow_output=$(stow $stow_flags "$package" 2>&1); then
                echo "$stow_output" | prefix_output "│ "
                INSTALLED_PACKAGES+=("$package")
                log_success "Installed $package"
                stow_result=0
            elif echo "$stow_output" | grep -q "existing target is neither a link nor a directory"; then
                # Files exist but aren't symlinks - use --adopt to take ownership
                # Remove --restow from flags when adopting (can't restow if files already exist)
                local adopt_flags="--adopt --dir=$PACKAGES_DIR --target=$HOME"
                if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
                    adopt_flags="--verbose $adopt_flags"
                fi
                log_info "Adopting existing files for $package..."
                local adopt_output
                if adopt_output=$(stow $adopt_flags "$package" 2>&1); then
                    echo "$adopt_output" | prefix_output "│ "
                    INSTALLED_PACKAGES+=("$package")
                    log_success "Installed $package (adopted existing files)"
                    stow_result=0
                else
                    # Show stow error output to stderr so it's visible even when piped
                    echo "$adopt_output" | prefix_output "│ " >&2
                    log_error "Failed to install package: $package"
                    suggest_fixes "stow" "$package"
                    return 1
                fi
            else
                # Show stow error output to stderr so it's visible even when piped
                echo "$stow_output" | prefix_output "│ " >&2
                log_error "Failed to install package: $package"
                suggest_fixes "stow" "$package"
                return 1
            fi
        elif [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
            # Level 1+: Just show success per package (level 2 already handled above)
            if stow $stow_flags "$package" >/dev/null 2>&1; then
                INSTALLED_PACKAGES+=("$package")
                log_success "Installed $package"
                stow_result=0
            else
                # Capture and show stow error output
                stow_output=$(stow $stow_flags "$package" 2>&1) || true
                if echo "$stow_output" | grep -q "existing target is neither a link nor a directory"; then
                    # Files exist but aren't symlinks - use --adopt to take ownership
                    log_info "Adopting existing files for $package..."
                    local adopt_flags="--adopt --dir=$PACKAGES_DIR --target=$HOME"
                    if adopt_output=$(stow $adopt_flags "$package" 2>&1); then
                        INSTALLED_PACKAGES+=("$package")
                        log_success "Installed $package (adopted existing files)"
                        stow_result=0
                    else
                        echo "$adopt_output" | prefix_output "│ " >&2
                        log_error "Failed to install package: $package"
                        suggest_fixes "stow" "$package"
                        return 1
                    fi
                else
                    echo "$stow_output" | prefix_output "│ " >&2
                    log_error "Failed to install package: $package"
                    suggest_fixes "stow" "$package"
                    return 1
                fi
            fi
        else
            # Level 0: Silent, no package messages
            if stow $stow_flags "$package" >/dev/null 2>&1; then
                INSTALLED_PACKAGES+=("$package")
                stow_result=0
            else
                # Capture and show stow error output
                stow_output=$(stow $stow_flags "$package" 2>&1) || true
                if echo "$stow_output" | grep -q "existing target is neither a link nor a directory"; then
                    # Files exist but aren't symlinks - use --adopt to take ownership
                    log_info "Adopting existing files for $package..."
                    local adopt_flags="--adopt --dir=$PACKAGES_DIR --target=$HOME"
                    if adopt_output=$(stow $adopt_flags "$package" 2>&1); then
                        INSTALLED_PACKAGES+=("$package")
                        log_success "Installed $package (adopted existing files)"
                        stow_result=0
                    else
                        echo "$adopt_output" | prefix_output "│ " >&2
                        log_error "Failed to install package: $package"
                        suggest_fixes "stow" "$package"
                        return 1
                    fi
                else
                    echo "$stow_output" | prefix_output "│ " >&2
                    log_error "Failed to install package: $package"
                    suggest_fixes "stow" "$package"
                    return 1
                fi
            fi
        fi
    done

    return 0
}

# Suggest fixes for common errors
suggest_fixes() {
    local operation="$1"
    local context="$2"

    echo ""
    echo "Suggested fixes:"

    case $operation in
        stow)
            echo "  1. Check for conflicting files: ./dot status"
            echo "  2. Remove or backup conflicting files in $HOME"
            echo "  3. Check stow output above for specific conflicts"
            echo "  4. Try: stow --adopt $context (adopts existing files)"
            ;;
        backup)
            echo "  1. Check disk space: df -h $DOTFILES_DIR/backups"
            echo "  2. Check permissions: ls -la $DOTFILES_DIR/backups"
            echo "  3. Clean old backups: ./dot clean"
            ;;
        template)
            echo "  1. Check template exists: ls -la $DOTFILES_DIR/$context"
            echo "  2. Check target directory permissions"
            echo "  3. Verify template file is readable"
            ;;
        git-config)
            echo "  1. Check config syntax: git config --file $context --list"
            echo "  2. Verify file format (key=value)"
            echo "  3. Check for invalid characters or encoding issues"
            ;;
        network)
            echo "  1. Check internet connection: ping -c 1 github.com"
            echo "  2. Check if behind proxy/firewall"
            echo "  3. Try again later or check $context URL manually"
            ;;
        submodules)
            echo "  1. Check git access: git ls-remote $context"
            echo "  2. Verify SSH keys: ssh -T git@github.com"
            echo "  3. Try: cd $DOTFILES_DIR && git submodule update --init --recursive"
            ;;
        *)
            echo "  1. Check logs above for specific error details"
            echo "  2. Run with verbose mode: ./dot install -v"
            echo "  3. Check GitHub issues: https://github.com/hamishmorgan/.dotfiles/issues"
            ;;
    esac
    echo ""
}

# Check if file is properly linked
check_symlink() {
    local file="$1"
    local expected_target="$2"

    if [[ -L "$HOME/$file" ]]; then
        local target
        target=$(readlink "$HOME/$file")
        if [[ "$target" == *"$expected_target"* ]]; then
            log_success "$file is properly linked to $target"
            return 0
        else
            log_warning "$file is linked to $target (expected $expected_target)"
            return 1
        fi
    elif [[ -d "$HOME/$file" ]]; then
        # Directory exists - check if it contains stow-managed files
        # (Stow creates directories when linking nested structures)
        log_success "$file exists as directory (stow-managed)"
        return 0
    elif [[ -f "$HOME/$file" ]]; then
        log_warning "$file exists but is not a symlink"
        return 1
    else
        log_error "$file not found"
        return 1
    fi
}

# Generic package validation function
# Optional verbosity parameter for enhanced output
validate_package() {
    local package="$1"
    local verbosity="${2:-0}"

    if ! load_package_manifest "$package"; then
        log_error "Package '$package' missing manifest: $PACKAGES_DIR/$package/manifest.toml"
        return 1
    fi

    local display_name="${PACKAGE_NAME:-$package}"
    local files="$PACKAGE_FILES"
    # Expand wildcards in file patterns
    files=$(expand_file_patterns "$package" "$files")

    log_info "Validating $display_name configuration..."

    # At verbosity 2+, show which files are being validated
    if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
        IFS=',' read -ra file_array <<< "$files"
        log_info "    Files to check: ${#file_array[@]}"
        for file in "${file_array[@]}"; do
            file=$(echo "$file" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
            log_info "      - $file"
        done
    fi

    local errors=0
    IFS=',' read -ra file_array <<< "$files"

    for file in "${file_array[@]}"; do
        # Trim whitespace from file path (handles leading/trailing spaces from TOML parsing)
        file=$(echo "$file" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
        # Check symlinks contain .dotfiles/packages/$package/ with trailing slash
        # - .dotfiles/packages/ matches the packages/ directory structure
        # - trailing slash prevents false positives with siblings like git-old/
        # Note: Uses substring matching, not canonical path verification (Issue #100)
        if ! check_symlink "$file" ".dotfiles/packages/$package/"; then
            # check_symlink already logs the error, but we need to track it
            ((errors++))
        fi
    done

    if [[ $errors -eq 0 ]]; then
        log_success "$display_name configuration validated successfully"
        return 0
    else
        log_error "$display_name validation failed with $errors errors"
        return 1
    fi
}

# Get list of backup directories
get_backup_dirs() {
    local backup_dirs=()
    shopt -s nullglob
    for dir in "$DOTFILES_DIR"/${BACKUP_DIR_PREFIX}-*; do
        if [[ -d "$dir" ]]; then
            backup_dirs+=("$dir")
        fi
    done
    shopt -u nullglob
    printf '%s\n' "${backup_dirs[@]}"
}

# Get backup statistics (count and total size)
# Returns: "count size_kb" (space-separated)
# Usage: read -r count size_kb <<< "$(get_backup_stats)"
get_backup_stats() {
    local count=0
    local total_size=0

    while IFS= read -r dir; do
        [[ -z "$dir" ]] && continue
        ((count++))
        local size
        size=$(du -sk "$dir" 2>/dev/null | cut -f1)
        ((total_size += size))
    done < <(get_backup_dirs)

    echo "$count $total_size"
}

# Automatically cleanup old backups if threshold exceeded
auto_cleanup_backups() {
    local backup_count
    backup_count=$(get_backup_dirs | wc -l | tr -d ' ')

    if [[ $backup_count -le $MAX_BACKUPS_TO_KEEP ]]; then
        return 0
    fi

    local backups_to_remove=$((backup_count - MAX_BACKUPS_TO_KEEP))
    log_info "Auto cleanup: $backup_count backups found, keeping $MAX_BACKUPS_TO_KEEP most recent, removing $backups_to_remove old backup(s)"

    clean_backups_silent "$MAX_BACKUPS_TO_KEEP"

    return 0
}

# Silent version of clean_backups for auto-cleanup
clean_backups_silent() {
    local keep_count="${1:-$MAX_BACKUPS_TO_KEEP}"

    # Avoid array operations in Bash 3.2 - use counter instead
    local total_backups=0
    local backup_list=""
    while IFS= read -r dir; do
        if [[ -n "$dir" ]]; then
            if [[ -z "$backup_list" ]]; then
                backup_list="$dir"
            else
                backup_list="$backup_list"$'\n'"$dir"
            fi
            ((total_backups++))
        fi
    done < <(get_backup_dirs | sort -r)

    if [[ $total_backups -eq 0 ]]; then
        return 0
    fi

    local removed_count=0
    local index=0

    while IFS= read -r backup; do
        [[ -z "$backup" ]] && continue
        if [[ $index -ge $keep_count ]]; then
            if rm -rf "$backup" 2>/dev/null; then
                ((removed_count++))
            fi
        fi
        ((index++))
    done <<< "$backup_list"

    if [[ $removed_count -gt 0 ]]; then
        log_success "Removed $removed_count old backup(s)"
    fi

    return 0
}

# Count orphaned symlinks in home and .config directories
# Returns: count of orphaned symlinks
count_orphaned_symlinks() {
    local count=0

    # Check home directory dotfiles
    while IFS= read -r link; do
        [[ -L "$link" ]] && [[ ! -e "$link" ]] && ((count++))
    done < <(find "$HOME" -maxdepth 1 -type l -name ".*" 2>/dev/null)

    # Check .config directory
    if [[ -d "$HOME/.config" ]]; then
        while IFS= read -r link; do
            [[ -L "$link" ]] && [[ ! -e "$link" ]] && ((count++))
        done < <(find "$HOME/.config" -maxdepth 2 -type l 2>/dev/null)
    fi

    echo "$count"
}

# Show installation summary (used by install and update at verbosity 0)
show_installation_summary() {
    echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} Dependencies satisfied"
    echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} Submodules initialized"
    echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} Templates processed"
    echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} Secret configs merged"
    echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} Packages installed"
}

# Display a single tip message
# Usage: show_tip "Run './dot health' to check"
show_tip() {
    echo -e "${BLUE}💡 Tip: $1${NC}"
}

# Display titled tips section with multiple items
# Usage: show_tips "Title" "Tip 1" "Tip 2" ...
show_tips() {
    local title="$1"
    shift

    echo ""
    echo -e "${BLUE}💡 ${title}:${NC}"
    while [[ $# -gt 0 ]]; do
        echo "   $1"
        shift
    done
}

# Show installation status
show_status() {
    show_command_header "Dotfiles Installation Status"

    # Count files and issues
    local total_files=0
    local installed_files=0
    local warning_files=0
    local missing_files=0

    show_section_separator "Installed Packages"
    echo ""

    # Generate file list dynamically from package definitions
    for package in "${PACKAGES[@]}"; do
        # Load manifest to get display name
        if ! load_package_manifest "$package" true; then
            continue
        fi

        local display_name="${PACKAGE_NAME:-$package}"
        local files
        files=$(get_package_files "$package")
        # Expand wildcards in file patterns
        files=$(expand_file_patterns "$package" "$files")
        IFS=',' read -ra file_array <<< "$files"

        # Display package header
        echo -e "   ${BLUE} $display_name${NC}"

        for file in "${file_array[@]}"; do
            # Trim whitespace from file path (handles leading/trailing spaces from TOML parsing)
            file=$(echo "$file" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
            ((total_files++))
            if [[ -L "$HOME/$file" ]]; then
                local target
                target=$(readlink "$HOME/$file")
                echo -e "     ${GREEN}${SYMBOL_SUCCESS}${NC} $file ${BLUE}→${NC} $target"
                ((installed_files++))
            elif [[ -d "$HOME/$file" ]]; then
                # Check if directory contains stow-managed files
                local stow_managed=false
                local stow_links
                stow_links=$(find "$HOME/$file" -maxdepth 3 -type l -exec readlink {} \; 2>/dev/null)
                if echo "$stow_links" | grep -Fq ".dotfiles/$package"; then
                    stow_managed=true
                fi

                if [[ "$stow_managed" == true ]]; then
                    echo -e "     ${GREEN}${SYMBOL_SUCCESS}${NC} $file ${BLUE}(stow-managed directory)${NC}"
                    ((installed_files++))
                else
                    echo -e "     ${YELLOW}${SYMBOL_WARNING}${NC} $file ${BLUE}(directory, not stow-managed)${NC}"
                    ((warning_files++))
                fi
            elif [[ -e "$HOME/$file" ]]; then
                echo -e "     ${YELLOW}${SYMBOL_WARNING}${NC} $file ${BLUE}(exists but not a symlink)${NC}"
                ((warning_files++))
            else
                echo -e "     ${RED}${SYMBOL_ERROR}${NC} $file ${BLUE}(not found)${NC}"
                ((missing_files++))
            fi
        done

        echo ""
    done

    echo ""
    show_section_separator "Copy-Sync Packages"
    echo ""

    # Check all copy-sync packages for sync status
    local copy_sync_count=0
    for package in "${PACKAGES[@]}"; do
        # Load manifest - silent mode for optional package checks
        if ! load_package_manifest "$package" true; then
            continue
        fi

        # Capture method immediately after load to avoid stale values
        local package_method="$PACKAGE_METHOD"
        if [[ "$package_method" != "copy-sync" ]]; then
            continue
        fi

        ((copy_sync_count++))

        # Capture manifest values immediately after load to avoid stale values
        local package_dotfiles="$PACKAGES_DIR/$package"
        local package_system="$PACKAGE_TARGET"
        local package_name="${PACKAGE_NAME:-$package}"
        local package_files="$PACKAGE_FILES"

        if [[ -z "$package_system" ]]; then
            echo -e "   ${YELLOW}${SYMBOL_WARNING}${NC} $package_name ${BLUE}(unsupported platform)${NC}"
            continue
        fi

        if [[ ! -d "$package_dotfiles" ]]; then
            echo -e "   ${YELLOW}${SYMBOL_WARNING}${NC} $package_name ${BLUE}(package directory not found)${NC}"
            continue
        fi

        if [[ ! -d "$package_system" ]]; then
            echo -e "   ${YELLOW}${SYMBOL_WARNING}${NC} $package_name ${BLUE}(not installed on system)${NC}"
            echo -e "   ${BLUE}💡${NC} Run './dot sync $package' to create config directory"
            continue
        fi

        # Check sync status for each file in the package
        IFS=',' read -ra files <<< "$package_files"
        local all_synced=true
        local synced_files=()
        local unsynced_files=()

        for file in "${files[@]}"; do
            # Remove quotes and whitespace
            file=$(trim_quotes_and_whitespace "$file")

            local dotfile_path="$package_dotfiles/$file"
            local system_path="$package_system/$file"

            if [[ -f "$dotfile_path" ]] && [[ -f "$system_path" ]]; then
                if diff -q "$dotfile_path" "$system_path" >/dev/null 2>&1; then
                    synced_files+=("$file")
                else
                    unsynced_files+=("$file")
                    all_synced=false
                fi
            elif [[ -f "$system_path" ]]; then
                # File exists in system but not in dotfiles
                unsynced_files+=("$file")
                all_synced=false
            elif [[ -f "$dotfile_path" ]]; then
                # File exists in dotfiles but not in system
                unsynced_files+=("$file")
                all_synced=false
            fi
        done

        if [[ $all_synced == true ]] && [[ ${#synced_files[@]} -gt 0 ]]; then
            echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} $package_name ${BLUE}(all files synced)${NC}"
        else
            for file in "${synced_files[@]}"; do
                echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} $package_name/$file ${BLUE}(synced)${NC}"
            done
            for file in "${unsynced_files[@]}"; do
                echo -e "   ${YELLOW}${SYMBOL_WARNING}${NC} $package_name/$file ${BLUE}(out of sync)${NC}"
            done
            if [[ ${#unsynced_files[@]} -gt 0 ]]; then
                show_tips \
                    "Sync to system: ./dot sync $package" \
                    "Pull from system: ./dot pull $package"
            fi
        fi
    done

    if [[ $copy_sync_count -eq 0 ]]; then
        echo -e "   ${BLUE}${SYMBOL_INFO}${NC} No copy-sync packages configured"
    fi

    echo ""
    show_section_separator "Backups"
    echo ""

    # Get backup statistics
    local backup_count backup_size_kb
    read -r backup_count backup_size_kb <<< "$(get_backup_stats)"

    if [[ $backup_count -eq 0 ]]; then
        echo "   No backup directories found"
    else
        # Get sorted backup directories for display
        local backup_dirs=()
        while IFS= read -r dir; do
            backup_dirs+=("$dir")
        done < <(get_backup_dirs | sort -r)

        local show_count=$((backup_count < MAX_BACKUPS_TO_DISPLAY ? backup_count : MAX_BACKUPS_TO_DISPLAY))

        for ((i=0; i<show_count; i++)); do
            local dir="${backup_dirs[$i]}"
            echo "   $(basename "$dir") ($(du -sh "$dir" | cut -f1))"
        done

        if [[ $backup_count -gt $MAX_BACKUPS_TO_DISPLAY ]]; then
            echo "   ... and $((backup_count - MAX_BACKUPS_TO_DISPLAY)) older backup(s)"
        fi

        echo ""
        echo "   Total: $backup_count backup(s) using $((backup_size_kb / KB_TO_MB))MB"
    fi

    echo ""
    show_command_summary "info" "$installed_files of $total_files files installed"

    # Show actionable tips
    if [[ $missing_files -gt 0 || $warning_files -gt 0 ]]; then
        echo ""
        [[ $missing_files -gt 0 ]] && show_tip "Run './dot install' to create missing symlinks"
        [[ $backup_count -gt $MAX_BACKUPS_TO_KEEP ]] && show_tip "Run './dot clean' to remove old backups"
    elif [[ $backup_count -gt $MAX_BACKUPS_TO_KEEP ]]; then
        echo ""
        show_tip "Run './dot clean' to remove old backups"
    fi
    echo ""
}

# Show diff preview of what would change
show_diff_preview() {
    show_command_header "Dotfiles Diff Preview"

    log_info "Comparing current state with dotfiles repository..."
    echo ""

    local changes_found=false
    local new_files=0
    local modified_files=0
    local wrong_target_files=0

    show_section_separator "File Changes"
    echo ""

    for package in "${PACKAGES[@]}"; do
        local package_files
        package_files=$(get_package_files "$package")
        # Expand wildcards in file patterns
        package_files=$(expand_file_patterns "$package" "$package_files")

        IFS=',' read -ra files <<< "$package_files"

        for file in "${files[@]}"; do
            local dotfile_path="$DOTFILES_DIR/$package/$file"
            local home_path="$HOME/$file"

            # Skip if dotfile doesn't exist (shouldn't happen)
            [[ ! -e "$dotfile_path" ]] && continue

            if [[ -L "$home_path" ]]; then
                # It's a symlink - check target
                local target
                target=$(readlink "$home_path")
                local expected_target="$DOTFILES_DIR/$package/$file"

                # Check if symlink points to our dotfiles (allows any path format - absolute, relative, etc.)
                if [[ "$target" != *"${DOTFILES_DIR}/${package}/${file}"* ]]; then
                    echo -e "   ${YELLOW}${SYMBOL_WARNING}${NC} $file"
                    echo "      Current: symlink → $target"
                    echo "      Expected: symlink → $expected_target"
                    changes_found=true
                    ((wrong_target_files++))
                fi
                # Symlink points to correct location - no diff needed
            elif [[ -f "$home_path" ]]; then
                # Regular file - compare content
                if [[ -f "$dotfile_path" ]]; then
                    if ! diff -q "$home_path" "$dotfile_path" > /dev/null 2>&1; then
                        echo -e "   ${BLUE}${SYMBOL_INFO}${NC} $file ${YELLOW}(content differs)${NC}"

                        # Show diff preview (first 25 lines)
                        local diff_output
                        diff_output=$(diff -u "$home_path" "$dotfile_path" 2>/dev/null || true)

                        while IFS= read -r line; do
                            if [[ "$line" == -* ]]; then
                                echo -e "      ${RED}$line${NC}"
                            elif [[ "$line" == +* ]]; then
                                echo -e "      ${GREEN}$line${NC}"
                            else
                                echo "      $line"
                            fi
                        done < <(echo "$diff_output" | head -25)

                        local diff_lines
                        diff_lines=$(echo "$diff_output" | grep -c '^')
                        if [[ $diff_lines -gt 25 ]]; then
                            echo "      ... ($(( diff_lines - 25 )) more lines)"
                        fi

                        echo ""
                        changes_found=true
                        ((modified_files++))
                    fi
                fi
            elif [[ ! -e "$home_path" ]]; then
                # File doesn't exist - would be created
                echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} $file ${GREEN}(would create new symlink)${NC}"
                changes_found=true
                ((new_files++))
            fi
        done
    done

    if ! $changes_found; then
        echo "   ${GREEN}${SYMBOL_SUCCESS}${NC} No changes detected - system matches repository"
    fi

    echo ""
    show_section_separator "Summary"
    echo ""

    if $changes_found; then
        [[ $new_files -gt 0 ]] && echo "   ${GREEN}${SYMBOL_SUCCESS}${NC} New files: $new_files"
        [[ $modified_files -gt 0 ]] && echo "   ${BLUE}${SYMBOL_INFO}${NC} Modified files: $modified_files"
        [[ $wrong_target_files -gt 0 ]] && echo "   ${YELLOW}${SYMBOL_WARNING}${NC} Wrong targets: $wrong_target_files"
        echo ""
        show_tip "Run ${BLUE}./dot install${NC} to apply these changes"
    else
        log_success "System is up to date with repository"
    fi

    echo ""
}

# Get backup age in days
get_backup_age_days() {
    local backup="$1"
    local backup_mtime
    backup_mtime=$(stat -c %Y "$backup" 2>/dev/null || stat -f %m "$backup" 2>/dev/null)
    echo $(( ($(date +%s) - backup_mtime) / SECONDS_PER_DAY ))
}

# List all available backups with details
list_backups() {
    show_command_header "Available Backups"

    local backup_dirs=()
    while IFS= read -r dir; do
        backup_dirs+=("$dir")
    done < <(get_backup_dirs | sort -r)

    if [[ ${#backup_dirs[@]} -eq 0 ]]; then
        show_section_separator
        echo ""
        log_info "No backups found"
        echo ""
        show_section_separator
        echo ""
        return 0
    fi

    show_section_separator
    echo ""
    printf "  ${BLUE}%-5s %-35s %-12s %-20s${NC}\n" "ID" "Name" "Size" "Created"
    echo "  ────────────────────────────────────────────────────────────────────────────"

    local id=1
    for dir in "${backup_dirs[@]}"; do
        local name
        name=$(basename "$dir")
        local created
        created=$(date -r "$dir" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
        local size
        size=$(du -sh "$dir" 2>/dev/null | cut -f1)

        printf "  %-5s %-35s %-12s %-20s\n" "$id" "$name" "$size" "$created"
        ((id++))
    done

    echo ""
    show_section_separator
    echo ""
    log_info "Restore with: ${BLUE}./dot restore${NC} ${YELLOW}[BACKUP_ID|latest]${NC}"
    echo ""
}

# Restore from a specific backup
restore_from_backup() {
    local backup_id="$1"

    show_command_header "Dotfiles Restore"

    # Find backup directory
    local backup_dir=""
    if [[ "$backup_id" == "latest" ]]; then
        backup_dir=$(get_backup_dirs | sort -r | head -n 1)
        if [[ -z "$backup_dir" ]]; then
            log_error "No backups found"
            return 1
        fi
    else
        # Try exact directory name match first
        if [[ -d "$DOTFILES_DIR/backups/$backup_id" ]]; then
            backup_dir="$DOTFILES_DIR/backups/$backup_id"
        # Try with configured prefix
        elif [[ -d "$DOTFILES_DIR/${BACKUP_DIR_PREFIX}-$backup_id" ]]; then
            backup_dir="$DOTFILES_DIR/${BACKUP_DIR_PREFIX}-$backup_id"
        else
            log_error "Backup not found: $backup_id"
            log_info "Run ${BLUE}./dot backups${NC} to see available backups"
            return 1
        fi
    fi

    show_section_separator
    echo ""
    log_info "Backup: ${BLUE}$(basename "$backup_dir")${NC}"
    local created
    created=$(date -r "$backup_dir" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
    log_info "Created: $created"
    local size
    size=$(du -sh "$backup_dir" 2>/dev/null | cut -f1)
    log_info "Size: $size"
    echo ""

    # Show what will be restored
    log_info "Files to restore:"
    local file_count=0
    local max_display="$RESTORE_DISPLAY_LIMIT"

    while IFS= read -r file; do
        if [[ $file_count -lt $max_display ]]; then
            local rel_path="${file#"$backup_dir"/}"
            echo "  ${SYMBOL_INFO} $rel_path"
        fi
        ((file_count++))
    done < <(find "$backup_dir" -type f -o -type l 2>/dev/null)

    if [[ $file_count -gt $max_display ]]; then
        echo "  ... and $((file_count - max_display)) more file(s)"
    fi
    echo ""

    # Confirm restoration
    read -r -p "Restore from this backup? (y/N): " confirm
    if [[ "$confirm" != "y" ]]; then
        log_info "Restore cancelled"
        return 0
    fi

    # Create safety backup before restore
    local safety_backup
    safety_backup="$DOTFILES_DIR/${RESTORE_SAFETY_PREFIX}-$(date +%s)"
    log_info "Creating safety backup..."
    if ! backup_existing_to "$safety_backup"; then
        log_warning "Could not create safety backup, but continuing..."
    else
        log_success "Safety backup: $(basename "$safety_backup")"
    fi

    echo ""

    # Uninstall current dotfiles
    log_info "Removing current dotfiles..."
    cmd_uninstall > /dev/null 2>&1

    # Restore files
    log_info "Restoring files from backup..."
    if cp -r "$backup_dir/"* "$HOME/" 2>/dev/null; then
        log_success "Files restored successfully"
    else
        log_error "Some files failed to restore"
        log_warning "You may need to restore manually from: $backup_dir"
        return 1
    fi

    echo ""
    show_section_separator
    echo ""
    log_success "Restore complete"
    echo ""
    show_tip "Reload shell to pick up restored configurations"

    if [[ -n "$safety_backup" ]]; then
        echo ""
        log_info "Safety backup available at: $(basename "$safety_backup")"
    fi
    echo ""

    return 0
}

# Backup to a specific directory
backup_existing_to() {
    local target_dir="$1"

    mkdir -p "$target_dir" || return 1

    for package in "${PACKAGES[@]}"; do
        local package_files
        package_files=$(get_package_files "$package")
        # Expand wildcards in file patterns
        package_files=$(expand_file_patterns "$package" "$package_files")

        IFS=',' read -ra files <<< "$package_files"

        for file in "${files[@]}"; do
            local home_file="$HOME/$file"

            if [[ -e "$home_file" ]] || [[ -L "$home_file" ]]; then
                local file_dir
                file_dir=$(dirname "$file")

                mkdir -p "$target_dir/$file_dir"

                if [[ -L "$home_file" ]]; then
                    cp -P "$home_file" "$target_dir/$file" 2>/dev/null || true
                elif [[ -d "$home_file" ]]; then
                    cp -r "$home_file" "$target_dir/$file" 2>/dev/null || true
                else
                    cp "$home_file" "$target_dir/$file" 2>/dev/null || true
                fi
            fi
        done
    done

    return 0
}

# Clean up backup directories
clean_backups() {
    show_command_header "Backup Cleanup"

    local backup_dirs=()
    while IFS= read -r dir; do
        backup_dirs+=("$dir")
    done < <(get_backup_dirs | sort -r)

    local total_backups=${#backup_dirs[@]}

    if [[ $total_backups -eq 0 ]]; then
        show_section_separator
        echo ""
        log_info "No backup directories to clean"
        echo ""
        show_section_separator
        echo ""
        return 0
    fi

    # Configuration (can be overridden via environment)
    local keep_count=${BACKUP_KEEP_COUNT:-5}
    local keep_days=${BACKUP_KEEP_DAYS:-30}

    echo " ${BLUE}Policy:${NC} Keep $keep_count most recent OR newer than $keep_days days"
    echo ""

    # Categorize backups
    local -a to_remove=()
    local -a to_keep=()

    for i in "${!backup_dirs[@]}"; do
        local backup="${backup_dirs[$i]}"
        local backup_name
        backup_name=$(basename "$backup")

        # Keep first N backups regardless of age (sorted newest first)
        if [[ $i -lt $keep_count ]]; then
            to_keep+=("$backup")
            continue
        fi

        # For older backups, check age
        local backup_age_days
        backup_age_days=$(get_backup_age_days "$backup")

        if [[ $backup_age_days -gt $keep_days ]]; then
            to_remove+=("$backup")
        else
            to_keep+=("$backup")
        fi
    done

    # Show summary
    if [[ ${#to_remove[@]} -eq 0 ]]; then
        show_section_separator
        echo ""
        log_success "All backups within retention policy"
        echo ""
        show_section_separator
        echo ""
        return 0
    fi

    # Calculate size to free
    local remove_size=0
    for backup in "${to_remove[@]}"; do
        local size_kb
        size_kb=$(du -sk "$backup" 2>/dev/null | cut -f1)
        ((remove_size += size_kb))
    done

    show_section_separator "To Remove (${#to_remove[@]} backups, $((remove_size / KB_TO_MB))MB)"
    echo ""
    for backup in "${to_remove[@]}"; do
        local backup_name
        backup_name=$(basename "$backup")
        local size
        size=$(du -sh "$backup" 2>/dev/null | cut -f1)
        local age_days
        age_days=$(get_backup_age_days "$backup")
        echo "   - $backup_name ($size, ${age_days}d old)"
    done

    # Calculate size to keep
    local keep_size=0
    for backup in "${to_keep[@]}"; do
        local size_kb
        size_kb=$(du -sk "$backup" 2>/dev/null | cut -f1)
        ((keep_size += size_kb))
    done

    echo ""
    show_section_separator "To Keep (${#to_keep[@]} backups, $((keep_size / KB_TO_MB))MB)"
    echo ""
    for backup in "${to_keep[@]}"; do
        local backup_name
        backup_name=$(basename "$backup")
        local size
        size=$(du -sh "$backup" 2>/dev/null | cut -f1)
        echo "   - $backup_name ($size)"
    done

    echo ""
    show_section_separator
    echo ""
    read -p " Remove ${#to_remove[@]} old backup(s)? (y/N): " -n 1 -r
    echo
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Backup cleanup cancelled"
        echo ""
        return 0
    fi

    # Remove old backups
    local removed_count=0
    local freed_space=0

    for backup in "${to_remove[@]}"; do
        local backup_name
        backup_name=$(basename "$backup")
        local size_kb
        size_kb=$(du -sk "$backup" 2>/dev/null | cut -f1)

        if rm -rf "$backup" 2>/dev/null; then
            log_success "Removed $backup_name"
            ((removed_count++))
            ((freed_space += size_kb))
        else
            log_error "Failed to remove $backup_name"
        fi
    done

    echo ""
    show_command_summary "success" "Removed $removed_count backup(s), freed $((freed_space / KB_TO_MB))MB"
    echo ""

    return 0
}

# Uninstall dotfiles
uninstall_dotfiles() {
    show_command_header "Dotfiles Uninstall"

    show_section_separator "Removing Packages"
    echo ""

    local uninstalled_count=0
    for package in "${PACKAGES[@]}"; do
        if [[ ! -d "$PACKAGES_DIR/$package" ]]; then
            continue
        fi

        if stow --verbose --delete --dir="$PACKAGES_DIR" --target="$HOME" "$package" 2>&1 | indent_section_output; then
            ((uninstalled_count++))
        fi
    done

    echo ""
    show_command_summary "success" "Uninstalled $uninstalled_count package(s)"
    echo ""
}

# Main command handlers
cmd_install() {
    local verbosity="${1:-$VERBOSITY_TACITURN}"
    local start_time
    start_time=$(date +%s)

    show_command_header "Dotfiles Installation"
    INSTALLATION_IN_PROGRESS=true

    # Step 1: Backup
    if ! run_step "1" "Backup Existing Files" "$verbosity" $VERBOSITY_GARRULOUS "Backup completed" \
         "Backup failed - aborting installation" backup_existing; then
        log_info "Backup directory: $BACKUP_DIR"
        INSTALLATION_IN_PROGRESS=false
        return 1
    fi

    # Step 2: Install
    show_numbered_section "2" "Installation Pipeline"
    if ! run_with_verbosity "$verbosity" $VERBOSITY_LOQUACIOUS "" run_installation_pipeline "$verbosity"; then
        echo ""
        log_error "Installation pipeline failed"
        log_info "Run './dot health' to check installation state"
        INSTALLATION_IN_PROGRESS=false
        return 1
    fi

    # Show summary for normal output (level 0, not silent)
    if [[ $verbosity -eq $VERBOSITY_TACITURN ]]; then
        show_installation_summary
    fi
    echo ""

    INSTALLATION_IN_PROGRESS=false

    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))

    show_command_summary "success" "INSTALLED" "$duration"

    # Show tips (simple version to avoid Bash 3.2 array iteration issues)
    show_tips "Next steps" \
        "Restart your terminal to apply changes" \
        "Verify installation: $0 health"
    echo ""

    auto_cleanup_backups

    return 0
}


# Validate configuration syntax (manifest-based)
# Optional verbosity parameter for enhanced output
validate_config_syntax() {
    local verbosity="${1:-$VERBOSITY_TACITURN}"
    log_info "Validating configuration syntax..."

    local errors=0

    # Iterate through all packages
    for package in "${PACKAGES[@]}"; do
        if ! load_package_manifest "$package"; then
            continue
        fi

        # Resolve target directory based on method
        local target_dir
        if [[ "$PACKAGE_METHOD" == "copy-sync" ]]; then
            target_dir="$PACKAGE_TARGET"  # e.g., ~/.config/Cursor/User
        else
            target_dir="$PACKAGE_TARGET"  # Use PACKAGE_TARGET which includes platform-specific overrides
        fi
        # Normalize trailing slash
        target_dir="${target_dir%/}"

        # Skip packages without validation entries
        if ! get_validation_patterns "$PACKAGES_DIR/$package/manifest.toml" >/dev/null 2>&1; then
            # At verbosity 2+, show which packages are being skipped
            if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
                log_info "    Package $package: No validation rules defined"
            fi
            continue
        fi

        # For each file in files array
        IFS=',' read -ra file_array <<< "$PACKAGE_FILES"
        for file in "${file_array[@]}"; do
            # Skip directories (only validate files)
            if [[ "$file" == */ ]]; then
                continue
            fi

            # Resolve full file path based on target_dir
            local full_path="$target_dir/$file"

            # Check if file exists
            if [[ ! -f "$full_path" ]]; then
                # At verbosity 2+, show which files are being skipped
                if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
                    log_info "    Skipping $file (not installed at $full_path)"
                fi
                continue  # Skip if not installed
            fi

            # Find matching validator (exact match first, then glob patterns)
            local validator_cmd
            validator_cmd=$(get_validator_for_file "$file" "$package")
            if [[ -n "$validator_cmd" ]]; then
                # Extract command and args from validator_cmd (format: "cmd|arg1,arg2,arg3")
                local cmd args_string
                cmd="${validator_cmd%%|*}"
                args_string="${validator_cmd#*|}"

                # Show validator command at verbosity 2+
                if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
                    log_info "    Validator: $cmd (args: ${args_string//file/<file>})"
                fi

                # Convert args string to array
                local validator_args=()
                if [[ -n "$args_string" ]]; then
                    IFS=',' read -ra validator_args <<< "$args_string"
                fi

                # Replace "file" placeholder in args array
                # The placeholder can appear as a standalone argument OR within a string argument
                local expanded_args=()
                for arg in "${validator_args[@]}"; do
                    if [[ "$arg" == "file" ]]; then
                        # Standalone "file" argument - replace with full path
                        expanded_args+=("$full_path")
                    elif [[ "$arg" == *"file"* ]]; then
                        # "file" appears within the argument (e.g., in Python code string)
                        # Replace all occurrences
                        local replaced_arg="${arg//file/$full_path}"
                        expanded_args+=("$replaced_arg")
                    else
                        expanded_args+=("$arg")
                    fi
                done

                # Execute validator
                VALIDATOR_ERROR_OUTPUT=""
                if ! run_validator "$cmd" "${expanded_args[@]}"; then
                    log_error "Validation failed: $file"
                    if [[ -n "$VALIDATOR_ERROR_OUTPUT" ]]; then
                        # Show validator error output (indented)
                        echo "$VALIDATOR_ERROR_OUTPUT" | sed 's/^/    /' >&2
                    else
                        # Fallback if no error output captured
                        log_info "    Validator command failed: $cmd ${expanded_args[*]}"
                    fi
                    # At verbosity 2+, show the full command that was executed
                    if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
                        log_info "    Executed: $cmd ${expanded_args[*]}"
                    fi
                    ((errors++))
                else
                    log_success "Validation passed: $file"
                    # At verbosity 2+, show the command that succeeded
                    if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
                        log_info "    Executed: $cmd ${expanded_args[*]}"
                    fi
                fi
            fi
            # No validator found = skip (opt-in)
        done
    done

    return $errors
}

# Check for orphaned symlinks
check_orphaned_symlinks() {
    log_info "Checking for orphaned symlinks..."

    local orphaned=0

    # Check dotfiles in home directory
    while IFS= read -r link; do
        if [[ -L "$link" ]] && [[ ! -e "$link" ]]; then
            log_warning "Orphaned symlink: ${link#"$HOME"/}"
            ((orphaned++))
        fi
    done < <(find "$HOME" -maxdepth 1 -type l -name ".*" 2>/dev/null)

    # Check .config directory
    if [[ -d "$HOME/.config" ]]; then
        while IFS= read -r link; do
            if [[ -L "$link" ]] && [[ ! -e "$link" ]]; then
                log_warning "Orphaned symlink: ${link#"$HOME"/}"
                ((orphaned++))
            fi
        done < <(find "$HOME/.config" -maxdepth 2 -type l 2>/dev/null)
    fi

    if [[ $orphaned -eq 0 ]]; then
        log_success "No orphaned symlinks found"
    else
        log_warning "Found $orphaned orphaned symlink(s)"
    fi

    return $orphaned
}

# Validate all package manifests
validate_all_manifests() {
    local errors=0

    for package in "${PACKAGES[@]}"; do
        local manifest="$PACKAGES_DIR/$package/manifest.toml"

        # Require manifest for all packages (MANDATORY - no fallback)
        if [[ ! -f "$manifest" ]]; then
            log_error "Package '$package' missing required manifest: $manifest" >&2
            log_error "All packages must have a manifest.toml file" >&2
            ((errors++))
            continue
        fi

        # Check manifest is readable
        if [[ ! -r "$manifest" ]]; then
            log_error "Package '$package' manifest not readable: $manifest" >&2
            ((errors++))
            continue
        fi

        # Validate manifest can be loaded and parsed
        if ! load_package_manifest "$package" false >/dev/null 2>&1; then
            # Capture error for display
            local load_error
            load_error=$(load_package_manifest "$package" false 2>&1)
            log_error "Package '$package' has invalid manifest:" >&2
            echo "$load_error" | grep -E "Error|error|ERROR" >&2
            ((errors++))
            continue
        fi

        # Validate syntax (TOML structure)
        local syntax_error
        if ! syntax_error=$(validate_manifest_syntax "$manifest" 2>&1); then
            log_error "Package '$package' manifest has syntax errors:" >&2
            echo "$syntax_error" | head -5 >&2
            ((errors++))
        fi

        # Validate semantics (file existence, method validity)
        local semantic_error
        if ! semantic_error=$(validate_manifest_semantic "$package" 2>&1); then
            log_error "Package '$package' manifest has semantic errors:" >&2
            echo "$semantic_error" | head -5 >&2
            ((errors++))
        fi
    done

    if [[ $errors -eq 0 ]]; then
        return 0
    else
        return "$errors"
    fi
}

# Check backup directory health
check_backup_health() {
    log_info "Checking backup directory health..."

    local backup_count=0
    local total_size=0

    while IFS= read -r dir; do
        [[ -z "$dir" ]] && continue
        ((backup_count++))
        local size
        size=$(du -sk "$dir" 2>/dev/null | cut -f1)
        ((total_size += size))
    done < <(find "$DOTFILES_DIR/backups" -maxdepth 1 -type d -name "dotfiles-backup-*" 2>/dev/null)

    if [[ $backup_count -eq 0 ]]; then
        log_info "No backup directories found"
    else
        log_info "Found $backup_count backup(s) using $((total_size / KB_TO_MB))MB"

        if [[ $backup_count -gt $MAX_BACKUPS_TO_KEEP ]]; then
            log_warning "Consider cleaning old backups: ./dot clean"
        fi
    fi

    return 0
}

# Check submodule health
check_submodule_health() {
    log_info "Checking submodule health..."

    local issues=0

    # Check if .gitmodules exists
    if [[ ! -f "$DOTFILES_DIR/.gitmodules" ]]; then
        log_info "No submodules configured"
        return 0
    fi

    # Check all submodules defined in .gitmodules
    if [[ -f "$DOTFILES_DIR/.gitmodules" ]]; then
        # Parse .gitmodules file to extract submodule paths
        # Format: [submodule "name"] ... path = actual/path
        local current_submodule=""
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue

            # Extract submodule name from [submodule "name"]
            if [[ "$line" =~ ^\s*\[submodule\ \"([^\"]+)\" ]]; then
                current_submodule="${BASH_REMATCH[1]}"
            # Extract path from "path = actual/path"
            elif [[ -n "$current_submodule" && "$line" =~ ^\s*path\s*=\s*(.+)$ ]]; then
                local submodule_rel_path="${BASH_REMATCH[1]}"
                submodule_rel_path=$(echo "$submodule_rel_path" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
                local submodule_full_path="$DOTFILES_DIR/$submodule_rel_path"

                if [[ -d "$submodule_full_path" ]]; then
                    # Check if submodule is initialized
                    if [[ -f "$submodule_full_path/.git" ]] || [[ -d "$submodule_full_path/.git" ]]; then
                        # Check for uncommitted changes in submodule
                        if git -C "$submodule_full_path" diff-index --quiet HEAD -- 2>/dev/null; then
                            log_success "Submodule $submodule_rel_path is clean"
                        else
                            log_warning "Submodule $submodule_rel_path has uncommitted changes"
                        fi

                        # Check if submodule is detached
                        if git -C "$submodule_full_path" symbolic-ref -q HEAD >/dev/null 2>&1; then
                            log_success "Submodule $submodule_rel_path on branch"
                        else
                            log_info "Submodule $submodule_rel_path in detached HEAD state (normal)"
                        fi
                    else
                        log_error "Submodule $submodule_rel_path not initialized"
                        log_info "Run: git submodule update --init --recursive"
                        ((issues++))
                    fi
                else
                    log_error "Submodule directory missing: $submodule_rel_path"
                    ((issues++))
                fi

                # Reset for next submodule
                current_submodule=""
            fi
        done < "$DOTFILES_DIR/.gitmodules"
    fi

    return $issues
}

# Check git repository status
check_git_repo_status() {
    log_info "Checking dotfiles repository status..."

    local issues=0

    # Check if in a git repository
    if ! git -C "$DOTFILES_DIR" rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not in a git repository"
        return 1
    fi

    # Check for uncommitted changes
    if git -C "$DOTFILES_DIR" diff-index --quiet HEAD -- 2>/dev/null; then
        log_success "Working directory clean"
    else
        log_warning "Working directory has uncommitted changes"
        local changed_count
        changed_count=$(git -C "$DOTFILES_DIR" status --porcelain | wc -l)
        log_info "  $changed_count file(s) modified"
    fi

    # Check current branch
    local current_branch
    current_branch=$(git -C "$DOTFILES_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null)
    log_info "Current branch: $current_branch"

    # Check if branch has upstream
    if git -C "$DOTFILES_DIR" rev-parse --abbrev-ref '@{upstream}' >/dev/null 2>&1; then
        # Check if up to date with remote
        git -C "$DOTFILES_DIR" fetch origin "$current_branch" --dry-run 2>/dev/null
        local ahead
        local behind
        ahead=$(git -C "$DOTFILES_DIR" rev-list --count '@{upstream}..HEAD' 2>/dev/null || echo "0")
        behind=$(git -C "$DOTFILES_DIR" rev-list --count 'HEAD..@{upstream}' 2>/dev/null || echo "0")

        if [[ $ahead -eq 0 ]] && [[ $behind -eq 0 ]]; then
            log_success "Up to date with origin"
        elif [[ $ahead -gt 0 ]] && [[ $behind -eq 0 ]]; then
            log_warning "Branch is ahead of origin by $ahead commit(s)"
            log_info "  Consider: git push"
        elif [[ $ahead -eq 0 ]] && [[ $behind -gt 0 ]]; then
            log_warning "Branch is behind origin by $behind commit(s)"
            log_info "  Consider: git pull"
            ((issues++))
        else
            log_warning "Branch has diverged ($ahead ahead, $behind behind)"
            log_info "  Consider: git pull --rebase"
            ((issues++))
        fi
    else
        log_info "No upstream branch configured"
    fi

    return $issues
}

# Check template and secret config consistency
check_template_consistency() {
    log_info "Checking template/secret config consistency..."

    local issues=0

    # Discover templates
    local template_list
    template_list=$(discover_templates)

    if [[ -z "$template_list" ]]; then
        log_info "No templates configured"
        return 0
    fi

    # Check each template
    while IFS=: read -r template target; do
        [[ -z "$template" ]] && continue

        local secret="${template%.template}.secret"
        local package_dir
        package_dir=$(dirname "$template")
        local target_file="$HOME/$target"

        # Check if secret config exists
        if [[ ! -f "$secret" ]]; then
            log_warning "Template without secret config: ${template#"$DOTFILES_DIR"/}"
            log_info "  Consider creating: ${secret#"$DOTFILES_DIR"/}"
        fi

        # Check if merged file is stale
        if [[ -f "$target_file" ]] && [[ -f "$secret" ]]; then
            if [[ "$template" -nt "$target_file" ]] || [[ "$secret" -nt "$target_file" ]]; then
                log_warning "Stale merged config: ${target_file#"$HOME"/}"
                log_info "  Source files newer than target. Run: ./dot install"
                ((issues++))
            else
                log_success "${target} up to date"
            fi
        fi
    done <<< "$template_list"

    # Check for orphaned secret configs
    while IFS= read -r secret; do
        [[ -z "$secret" ]] && continue

        local template="${secret%.secret}.template"
        if [[ ! -f "$template" ]]; then
            log_warning "Secret config without template: ${secret#"$DOTFILES_DIR"/}"
        fi
    done < <(discover_secret_configs)

    return $issues
}

# Check file permissions
check_file_permissions() {
    log_info "Checking file permissions..."

    local errors=0
    local warnings=0

    # Check secret config files (should not be world-readable)
    while IFS= read -r secret; do
        [[ -z "$secret" ]] && continue
        [[ ! -f "$secret" ]] && continue

        local perms
        perms=$(stat -c '%a' "$secret" 2>/dev/null || stat -f '%A' "$secret" 2>/dev/null)

        # Check if world-readable (last digit > 0)
        if [[ "${perms: -1}" != "0" ]]; then
            log_warning "Secret config is world-readable: ${secret#"$DOTFILES_DIR"/}"
            log_info "  Consider: chmod $SECRET_FILE_MODE $secret"
            ((warnings++))
        else
            log_success "${secret#"$DOTFILES_DIR"/} has secure permissions"
        fi
    done < <(discover_secret_configs)

    # Check for accidentally committed secrets (this is an ERROR not a warning)
    while IFS= read -r secret; do
        [[ -z "$secret" ]] && continue
        [[ ! -f "$secret" ]] && continue

        if git -C "$DOTFILES_DIR" ls-files --error-unmatch "$secret" >/dev/null 2>&1; then
            log_error "Secret config is tracked by git (potential secrets leak): ${secret#"$DOTFILES_DIR"/}"
            log_info "  Run: git rm --cached ${secret#"$DOTFILES_DIR"/}"
            ((errors++))
        fi
    done < <(discover_secret_configs)

    if [[ $errors -eq 0 ]] && [[ -n "$(discover_secret_configs)" ]]; then
        log_success "Secret configs properly ignored by git"
    fi

    if [[ $warnings -gt 0 ]]; then
        log_info "Found $warnings permission warning(s) - consider fixing for better security"
    fi

    return $errors
}

# Check shell integration
check_shell_integration() {
    log_info "Checking shell integration..."

    local issues=0

    # Detect current shell from environment
    local current_shell=""

    if [[ -n "$ZSH_VERSION" ]]; then
        current_shell="zsh"
    elif [[ -n "$BASH_VERSION" ]]; then
        current_shell="bash"
    elif [[ -n "$FISH_VERSION" ]]; then
        current_shell="fish"
    fi

    # If we know the current shell, find its package and check config files
    if [[ -n "$current_shell" ]]; then
        # Try to find matching shell package (case-insensitive match)
        local shell_package=""
        for package in "${PACKAGES[@]}"; do
            if ! load_package_manifest "$package" true; then
                continue
            fi

            local package_lower
            package_lower=$(echo "$PACKAGE_NAME" | tr '[:upper:]' '[:lower:]')
            if [[ "$package_lower" == *"$current_shell"* ]]; then
                shell_package="$package"
                break
            fi
        done

        # If we found a shell package, check its config files
        if [[ -n "$shell_package" ]]; then
            if ! load_package_manifest "$shell_package"; then
                log_warning "Shell package '$shell_package' manifest not found"
                ((issues++))
            else
                # Check each config file in the package
                IFS=',' read -ra files <<< "$PACKAGE_FILES"
                local found_config=false

                for file in "${files[@]}"; do
                    # Remove quotes and whitespace
                    file=$(trim_quotes_and_whitespace "$file")

                    # Skip directories and non-config files
                    if [[ "$file" == */ ]] || [[ "$file" == *".example"* ]] || [[ "$file" == *"/functions"* ]]; then
                        continue
                    fi

                    # Resolve config file path
                    local config_path="$HOME/$file"

                    if [[ -L "$config_path" ]]; then
                        found_config=true
                        local target
                        target=$(readlink "$config_path")
                        if [[ "$target" == *".dotfiles"* ]]; then
                            log_success "Using dotfiles $file"
                        else
                            log_warning "Shell config symlink points elsewhere: $target"
                            ((issues++))
                        fi
                    elif [[ -f "$config_path" ]]; then
                        found_config=true
                        log_error "$file is not a symlink to dotfiles"
                        ((issues++))
                    fi
                done

                if [[ "$found_config" == false ]]; then
                    log_warning "No shell config files found for $current_shell package"
                fi
            fi
        else
            log_info "No package found for current shell: $current_shell"
        fi
    else
        log_info "Current shell not detected (ZSH_VERSION/BASH_VERSION/FISH_VERSION not set)"
    fi

    # Check PATH includes our custom directories
    if [[ ":$PATH:" == *":$HOME/bin:"* ]] || [[ ":$PATH:" == *":$HOME/.local/bin:"* ]]; then
        log_success "Custom bin directories in PATH"
    else
        log_warning "Custom bin directories not in PATH"
        log_info "  Expected: ~/bin or ~/.local/bin in PATH"
    fi

    # Check if dotfiles repo is in expected location
    if [[ "$DOTFILES_DIR" == "$HOME/.dotfiles" ]]; then
        log_success "Dotfiles in standard location"
    else
        log_info "Dotfiles location: $DOTFILES_DIR (non-standard)"
    fi

    return $issues
}

# Check for stow conflicts
check_stow_conflicts() {
    log_info "Checking for potential stow conflicts..."

    local issues=0

    # Check each package for potential conflicts
    for package in "${PACKAGES[@]}"; do
        local package_dir="$DOTFILES_DIR/$package"
        [[ ! -d "$package_dir" ]] && continue

        # Find all files in package
        while IFS= read -r file; do
            [[ -z "$file" ]] && continue

            local rel_path="${file#"$package_dir"/}"
            local target_path="$HOME/$rel_path"

            # Skip if it's already our symlink
            if [[ -L "$target_path" ]]; then
                local link_target
                link_target=$(readlink "$target_path")
                if [[ "$link_target" == *".dotfiles/$package"* ]]; then
                    continue
                fi
            fi

            # Check if target exists but is not our symlink
            if [[ -e "$target_path" ]] && [[ ! -L "$target_path" ]]; then
                log_warning "Unmanaged file would conflict: $rel_path"
                log_info "  File exists but not managed by stow"
                ((issues++))
            fi
        done < <(find "$package_dir" -type f -not -path "*/.*" 2>/dev/null)
    done

    if [[ $issues -eq 0 ]]; then
        log_success "No stow conflicts detected"
    fi

    return $issues
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Unified Display Functions
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Display a command header
show_command_header() {
    local title="$1"
    echo ""
    echo -e "${BLUE}╭──────────────────────────────────────────────────────────╮${NC}"
    printf "${BLUE}│${NC}  %-56s${BLUE}│${NC}\n" "$title"
    echo -e "${BLUE}╰──────────────────────────────────────────────────────────╯${NC}"
    echo ""
}

# Display a section separator with title
show_section_separator() {
    local title="$1"
    if [[ -n "$title" ]]; then
        echo -e " ${BLUE}${title}${NC} ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    else
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    fi
}

# Display a numbered section separator
show_numbered_section() {
    local num="$1"
    local title="$2"
    echo -e " ${BLUE}${num}. ${title}${NC} ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
}

# Display a command summary/result
show_command_summary() {
    local status="$1"      # "success" or "info"
    local message="$2"
    local duration="$3"     # optional

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if [[ "$status" == "success" ]]; then
        if [[ -n "$duration" ]]; then
            printf " Result: %b${SYMBOL_SUCCESS} ${message}%b" "$GREEN" "$NC"
            local msg_len=$((10 + ${#message}))  # "Result: ✓ " + message (✓ = 2 cols)
            local padding=$((47 - msg_len))
            [[ $padding -lt 1 ]] && padding=1
            printf "%${padding}s" ""
            printf "Duration: %.1fs\n" "$duration"
        else
            printf " %b${SYMBOL_SUCCESS} ${message}%b\n" "$GREEN" "$NC"
        fi
    else
        printf " %b${SYMBOL_INFO} ${message}%b\n" "$BLUE" "$NC"
    fi

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# Display table header
show_health_table_header() {
    echo ""
    echo -e "${BLUE}╭──────────────────────────────────────────────────────────╮${NC}"
    echo -e "${BLUE}│${NC}  Dotfiles Health Check                                   ${BLUE}│${NC}"
    echo -e "${BLUE}╰──────────────────────────────────────────────────────────╯${NC}"
    echo ""
    printf " %-28s %-12s %s\n" "Category" "Status" "Details"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# Display table row with spinner
show_health_check_spinner() {
    local num="$1"
    local category="$2"
    local verbosity="${3:-$VERBOSITY_TACITURN}"

    # Skip in silent mode
    if [[ $verbosity -eq $VERBOSITY_MUTE ]]; then
        return
    fi

    # Show spinner - ⠿ is a wide character (2 cols)
    printf " %3s %-25s ${BLUE}⠿ Checking...${NC}\r" "$num." "$category"  # Right-align number with dot
}

# Display table row
show_health_table_row() {
    local num="$1"
    local category="$2"
    local status="$3"
    local details="$4"
    local verbosity="${5:-$VERBOSITY_TACITURN}"

    # Skip in silent mode
    if [[ $verbosity -eq $VERBOSITY_MUTE ]]; then
        return
    fi

    local status_text
    local status_color
    case "$status" in
        pass)
            status_text="${SYMBOL_SUCCESS} Pass"
            status_color="$GREEN"
            ;;
        fail)
            status_text="${SYMBOL_ERROR} Fail"
            status_color="$RED"
            ;;
        warn)
            status_text="${SYMBOL_WARNING} Warn"
            status_color="$YELLOW"
            ;;
        info)
            status_text="${SYMBOL_INFO} Info"
            status_color="$BLUE"
            ;;
    esac

    # Clear the spinner line and show result
    # Note: Success/Error/Warning symbols are wide chars (2 cols), Info is regular (1 col)
    # "✓ Pass" visually = 2+1+4 = 7 cols, need 12 total = 5 more spaces
    # "⚠ Warn" visually = 2+1+4 = 7 cols, need 12 total = 5 more spaces
    # "∙ Info" visually = 1+1+4 = 6 cols, need 12 total = 6 more spaces
    # "✗ Fail" visually = 2+1+4 = 7 cols, need 12 total = 5 more spaces
    printf "\r\033[K %3s %-25s " "$num." "$category"  # Right-align number with dot (max "11.")

    # Add extra space for info status since ∙ is narrower than emoji
    if [[ "$status" == "info" ]]; then
        printf "%b%s%b      " "$status_color" "$status_text" "$NC"  # 6 spaces for info
    else
        printf "%b%s%b     " "$status_color" "$status_text" "$NC"  # 5 spaces for others
    fi

    printf "%s\n" "$details"
}

# Display health summary
show_health_summary() {
    local status="$1"
    local error_count="$2"
    local warn_count="$3"
    local duration="$4"

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if [[ "$status" == "healthy" ]]; then
        # Border = 60 visual cols total
        # " Result: ✓ HEALTHY" = 1 + 8 + 2 (wide symbol) + 8 = 19 visual cols
        # "Duration: X.Xs" = 14 chars
        # Padding: Use 23 spaces for better visual alignment with table above
        printf " Result: %b${SYMBOL_SUCCESS} HEALTHY%b" "$GREEN" "$NC"
        printf "%23s" ""
        printf "Duration: %.1fs\n" "$duration"
    else
        local issues_text="$error_count error"
        [[ $error_count -ne 1 ]] && issues_text="${issues_text}s"
        if [[ $warn_count -gt 0 ]]; then
            issues_text="$issues_text, $warn_count warning"
            [[ $warn_count -ne 1 ]] && issues_text="${issues_text}s"
        fi
        # " Result: ✗ UNHEALTHY (text)" - calculate padding for visual alignment
        # 1 + 8 + 2 (wide symbol) + 10 ("UNHEALTHY ") + 1 ("(") + text + 1 (")") = 23 + text
        local visible_length=$((23 + ${#issues_text}))
        local padding=$((42 - visible_length))  # Align with healthy case (23 spaces base)
        [[ $padding -lt 1 ]] && padding=1

        printf " Result: %b${SYMBOL_ERROR} UNHEALTHY%b (%s)" "$RED" "$NC" "$issues_text"
        printf "%${padding}s" ""
        printf "Duration: %.1fs\n" "$duration"
    fi

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# Count files/symlinks for a check
count_symlinks() {
    local count=0
    for package in "${PACKAGES[@]}"; do
        local files
        files=$(get_package_files "$package")
        # Expand wildcards in file patterns
        files=$(expand_file_patterns "$package" "$files")
        IFS=',' read -ra file_array <<< "$files"
        count=$((count + ${#file_array[@]}))
    done
    echo "$count"
}

# Comprehensive health check command (table format)
cmd_health() {
    local verbosity="${1:-$VERBOSITY_TACITURN}"

    # Quiet mode: only show errors, no output
    if [[ $verbosity -eq $VERBOSITY_MUTE ]]; then
        # Run checks silently, only capture errors
        local errors=0
        for package in "${PACKAGES[@]}"; do
            if ! validate_package "$package" "$verbosity" >/dev/null 2>&1; then
                ((errors++))
            fi
        done
        if ! validate_config_syntax "$verbosity" >/dev/null 2>&1; then
            ((errors++))
        fi
        # Only show errors if any found
        if [[ $errors -gt 0 ]]; then
            echo "Health check failed with $errors error(s)" >&2
            return 1
        fi
        return 0
    fi

    # If verbosity > 0, show detailed output
    if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
        cmd_health_verbose "$verbosity"
        return $?
    fi

    # Track timing
    local start_time
    start_time=$(date +%s)

    # Initialize result tracking (bash 3.2 compatible - parallel arrays)
    local check_statuses=()
    local check_details=()
    local check_outputs=()

    local total_errors=0
    local total_warnings=0

    # Display table header immediately (skip in silent mode)
    if [[ $verbosity -ge $VERBOSITY_TACITURN ]]; then
        show_health_table_header
    fi

    # Run checks and display results progressively
    local output
    local result

    # 1. Symlink integrity
    show_health_check_spinner "1" "Symlink Integrity" "$verbosity"
    output=""
    for package in "${PACKAGES[@]}"; do
        local package_output
        package_output=$(validate_package "$package" "$verbosity" 2>&1)
        local package_result=$?
        if [[ $package_result -ne 0 ]]; then
            output="${output}${package_output}\n"
            ((total_errors++))
        fi
    done

    if [[ -n "$output" ]]; then
        check_statuses+=("fail")
        check_details+=("Validation errors")
        check_outputs+=("$output")
        show_health_table_row "1" "Symlink Integrity" "fail" "Validation errors" "$verbosity"
    else
        local file_count
        file_count=$(count_symlinks)
        check_statuses+=("pass")
        check_details+=("$file_count files linked")
        check_outputs+=("")
        show_health_table_row "1" "Symlink Integrity" "pass" "$file_count files linked" "$verbosity"
    fi

    # 2. Configuration syntax
    show_health_check_spinner "2" "Configuration Syntax" "$verbosity"
    output=$(validate_config_syntax "$verbosity" 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("fail")
        check_details+=("Syntax errors")
        check_outputs+=("$output")
        ((total_errors += result))
        show_health_table_row "2" "Configuration Syntax" "fail" "Syntax errors" "$verbosity"
    else
        check_statuses+=("pass")
        check_details+=("All configs valid")
        check_outputs+=("")
        show_health_table_row "2" "Configuration Syntax" "pass" "All configs valid" "$verbosity"
    fi

    # 3. Submodule health
    show_health_check_spinner "3" "Submodule Health" "$verbosity"
    output=$(check_submodule_health 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("fail")
        check_details+=("Issues found")
        check_outputs+=("$output")
        ((total_errors += result))
        show_health_table_row "3" "Submodule Health" "fail" "Issues found" "$verbosity"
    else
        check_statuses+=("pass")
        check_details+=("All submodules clean")
        check_outputs+=("")
        show_health_table_row "3" "Submodule Health" "pass" "All submodules clean" "$verbosity"
    fi

    # 4. Git repository status
    show_health_check_spinner "4" "Git Repository" "$verbosity"
    output=$(check_git_repo_status 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("warn")
        check_details+=("Uncommitted changes")
        check_outputs+=("$output")
        ((total_warnings += result))
        show_health_table_row "4" "Git Repository" "warn" "Uncommitted changes" "$verbosity"
    else
        check_statuses+=("pass")
        check_details+=("Clean, up-to-date")
        check_outputs+=("")
        show_health_table_row "4" "Git Repository" "pass" "Clean, up-to-date" "$verbosity"
    fi

    # 5. Template/secret config consistency
    show_health_check_spinner "5" "Template Consistency" "$verbosity"
    output=$(check_template_consistency 2>&1)
    result=$?
    local template_count=0
    template_count=$(discover_templates | wc -l)
    if [[ $result -ne 0 ]]; then
        check_statuses+=("warn")
        check_details+=("Stale configs")
        check_outputs+=("$output")
        ((total_warnings += result))
        show_health_table_row "5" "Template Consistency" "warn" "Stale configs" "$verbosity"
    else
        check_statuses+=("pass")
        check_details+=("$template_count template(s) synced")
        check_outputs+=("")
        show_health_table_row "5" "Template Consistency" "pass" "$template_count template(s) synced" "$verbosity"
    fi

    # 6. File permissions
    show_health_check_spinner "6" "File Permissions" "$verbosity"
    output=$(check_file_permissions 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("fail")
        check_details+=("Insecure permissions")
        check_outputs+=("$output")
        ((total_errors += result))
        show_health_table_row "6" "File Permissions" "fail" "Insecure permissions" "$verbosity"
    else
        check_statuses+=("pass")
        check_details+=("Secrets secured")
        check_outputs+=("")
        show_health_table_row "6" "File Permissions" "pass" "Secrets secured" "$verbosity"
    fi

    # 7. Shell integration
    show_health_check_spinner "7" "Shell Integration" "$verbosity"
    output=$(check_shell_integration 2>&1)
    result=$?

    # Detect shell name from current environment and installed packages
    local shell_name=""
    if [[ -n "$ZSH_VERSION" ]]; then
        # Try to find zsh package name from manifest
        for package in "${PACKAGES[@]}"; do
            if load_package_manifest "$package" true; then
                local package_lower
                package_lower=$(echo "$PACKAGE_NAME" | tr '[:upper:]' '[:lower:]')
                if [[ "$package_lower" == *"zsh"* ]]; then
                    shell_name="$PACKAGE_NAME"
                    break
                fi
            fi
        done
        [[ -z "$shell_name" ]] && shell_name="Zsh"
    elif [[ -n "$BASH_VERSION" ]]; then
        # Try to find bash package name from manifest
        for package in "${PACKAGES[@]}"; do
            if load_package_manifest "$package" true; then
                local package_lower
                package_lower=$(echo "$PACKAGE_NAME" | tr '[:upper:]' '[:lower:]')
                if [[ "$package_lower" == *"bash"* ]]; then
                    shell_name="$PACKAGE_NAME"
                    break
                fi
            fi
        done
        [[ -z "$shell_name" ]] && shell_name="Bash"
    elif [[ -n "$FISH_VERSION" ]]; then
        # Try to find fish package name from manifest
        for package in "${PACKAGES[@]}"; do
            if load_package_manifest "$package" true; then
                local package_lower
                package_lower=$(echo "$PACKAGE_NAME" | tr '[:upper:]' '[:lower:]')
                if [[ "$package_lower" == *"fish"* ]]; then
                    shell_name="$PACKAGE_NAME"
                    break
                fi
            fi
        done
        [[ -z "$shell_name" ]] && shell_name="Fish"
    fi

    if [[ $result -ne 0 ]]; then
        check_statuses+=("warn")
        check_details+=("Issues detected")
        check_outputs+=("$output")
        ((total_warnings += result))
        show_health_table_row "7" "Shell Integration" "warn" "Issues detected" "$verbosity"
    else
        check_statuses+=("pass")
        if [[ -n "$shell_name" ]]; then
            check_details+=("$shell_name active")
        else
            check_details+=("Shell active")
        fi
        check_outputs+=("")
        if [[ -n "$shell_name" ]]; then
            show_health_table_row "7" "Shell Integration" "pass" "$shell_name active" "$verbosity"
        else
            show_health_table_row "7" "Shell Integration" "pass" "Shell active" "$verbosity"
        fi
    fi

    # 8. Stow conflicts
    show_health_check_spinner "8" "Stow Conflicts" "$verbosity"
    output=$(check_stow_conflicts 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("fail")
        check_details+=("$result conflict(s)")
        check_outputs+=("$output")
        ((total_errors += result))
        show_health_table_row "8" "Stow Conflicts" "fail" "$result conflict(s)" "$verbosity"
    else
        check_statuses+=("pass")
        check_details+=("No conflicts")
        check_outputs+=("")
        show_health_table_row "8" "Stow Conflicts" "pass" "No conflicts" "$verbosity"
    fi

    # 9. Orphaned symlinks
    show_health_check_spinner "9" "Orphaned Symlinks" "$verbosity"
    output=$(check_orphaned_symlinks 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("warn")
        check_details+=("$result found")
        check_outputs+=("$output")
        show_health_table_row "9" "Orphaned Symlinks" "warn" "$result found" "$verbosity"
        # Don't count as error, just warning
    else
        check_statuses+=("pass")
        check_details+=("None found")
        check_outputs+=("")
        show_health_table_row "9" "Orphaned Symlinks" "pass" "None found" "$verbosity"
    fi

    # 10. Dependencies
    show_health_check_spinner "10" "Dependencies" "$verbosity"
    if check_dependencies >/dev/null 2>&1; then
        check_statuses+=("pass")
        check_details+=("All satisfied")
        check_outputs+=("")
        show_health_table_row "10" "Dependencies" "pass" "All satisfied" "$verbosity"
    else
        output=$(check_dependencies 2>&1)
        check_statuses+=("fail")
        check_details+=("Missing deps")
        check_outputs+=("$output")
        ((total_errors++))
        show_health_table_row "10" "Dependencies" "fail" "Missing deps" "$verbosity"
    fi

    # 11. Backup health
    show_health_check_spinner "11" "Backup Health" "$verbosity"
    local backup_count backup_size_kb
    read -r backup_count backup_size_kb <<< "$(get_backup_stats)"

    if [[ $backup_count -eq 0 ]]; then
        check_statuses+=("pass")
        check_details+=("No backups")
        check_outputs+=("")
        show_health_table_row "11" "Backup Health" "pass" "No backups" "$verbosity"
    else
        check_statuses+=("info")
        check_details+=("$backup_count backups ($((backup_size_kb / KB_TO_MB))MB)")
        check_outputs+=("")
        show_health_table_row "11" "Backup Health" "info" "$backup_count backups ($((backup_size_kb / KB_TO_MB))MB)" "$verbosity"
    fi

    # Calculate duration
    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))

    echo ""

    # Show summary
    if [[ $total_errors -eq 0 ]]; then
        show_health_summary "healthy" 0 "$total_warnings" "$duration"
    else
        show_health_summary "unhealthy" "$total_errors" "$total_warnings" "$duration"
    fi

    echo ""

    # Check if we have maintenance items to show
    local has_maintenance=false
    if [[ "${check_statuses[8]}" == "warn" ]] || [[ "${check_statuses[10]}" == "info" && $backup_count -gt 10 ]]; then
        has_maintenance=true
    fi

    # Show detailed issues if any
    if [[ $total_errors -gt 0 ]] || [[ $total_warnings -gt 0 ]] || [[ "$has_maintenance" == "true" ]]; then
        local shown_errors=false
        local shown_warnings=false

        # Show errors first
        for i in "${!check_statuses[@]}"; do
            if [[ "${check_statuses[$i]}" == "fail" ]] && [[ -n "${check_outputs[$i]}" ]]; then
                if [[ "$shown_errors" == "false" ]]; then
                    echo -e "${RED}${SYMBOL_ERROR} Critical Issues:${NC}"
                    shown_errors=true
                fi

                local category_name=""
                case $i in
                    0) category_name="Symlink Integrity" ;;
                    1) category_name="Configuration Syntax" ;;
                    2) category_name="Submodule Health" ;;
                    3) category_name="Git Repository" ;;
                    4) category_name="Template Consistency" ;;
                    5) category_name="File Permissions" ;;
                    6) category_name="Shell Integration" ;;
                    7) category_name="Stow Conflicts" ;;
                    8) category_name="Orphaned Symlinks" ;;
                    9) category_name="Dependencies" ;;
                    10) category_name="Backup Health" ;;
                esac

                echo "  $((i + 1)). $category_name"
                echo -e "${check_outputs[$i]}" | sed 's/^/     /'
            fi
        done

        # Show warnings
        for i in "${!check_statuses[@]}"; do
            if [[ "${check_statuses[$i]}" == "warn" ]] && [[ -n "${check_outputs[$i]}" ]]; then
                # Check if there's actually output to display
                local warning_output
                warning_output=$(echo -e "${check_outputs[$i]}" | grep -E "^(${SYMBOL_WARNING}|${SYMBOL_INFO})")

                if [[ -n "$warning_output" ]]; then
                    if [[ "$shown_warnings" == "false" ]]; then
                        [[ "$shown_errors" == "true" ]] && echo ""
                        echo -e "${YELLOW}${SYMBOL_WARNING} Warnings:${NC}"
                        shown_warnings=true
                    fi

                    # shellcheck disable=SC2001
                    echo "$warning_output" | sed 's/^/  /'
                fi
            fi
        done

        # Show maintenance items
        if [[ "$has_maintenance" == "true" ]]; then
            [[ "$shown_errors" == "true" || "$shown_warnings" == "true" ]] && echo ""
            echo -e "${YELLOW}${SYMBOL_WARNING} Maintenance Items:${NC}"

            if [[ "${check_statuses[8]}" == "warn" ]]; then
                echo "  • ${check_details[8]} orphaned symlinks (non-critical)"
            fi

            if [[ "${check_statuses[10]}" == "info" && $backup_count -gt $MAX_BACKUPS_TO_KEEP ]]; then
                echo "  • $backup_count backups using $((backup_size_kb / KB_TO_MB))MB - run './dot clean' to free space"
            fi
        fi

        # Show quick fix suggestion
        if [[ $total_errors -gt 0 ]]; then
            echo ""
            show_tip "Quick fix: Run './dot install' to resolve most issues"
        fi
    fi

    echo ""
    show_tip "Run './dot health -v' for detailed output"
    echo ""

    # Return appropriate exit code
    if [[ $total_errors -eq 0 ]]; then
        return 0
    else
        return 1
    fi
}

# Indent output for verbose mode sections
indent_section_output() {
    # Indent 3 spaces and replace any remaining large dots (●) with SYMBOL_INFO (∙)
    # Note: log_info already outputs ∙ via SYMBOL_INFO, but this catches any legacy output
    sed 's/^/   /' | sed "s/●/${SYMBOL_INFO}/g"
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Execution Helpers - Reduce Verbosity Duplication
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Execute command with verbosity-appropriate output
# Usage: run_with_verbosity VERBOSITY THRESHOLD SUCCESS_MSG COMMAND [ARGS...]
# Arguments:
#   VERBOSITY - current verbosity level (0, 1, 2+)
#   THRESHOLD - verbosity level needed to show details (usually 1 or 2)
#   SUCCESS_MSG - message to show if successful and verbosity < threshold
#   COMMAND - command to execute
#   ARGS - arguments to command
# Returns: exit code of command
run_with_verbosity() {
    local verbosity="$1"
    local threshold="$2"
    local success_msg="$3"
    shift 3
    # Remaining args are the command to execute

    # Use -ge comparison: show details if verbosity >= threshold
    if [[ $verbosity -ge $threshold ]]; then
        # Show detailed output (indented)
        # Use pipefail to ensure command exit code is preserved
        local output
        local exit_code
        set -o pipefail
        output=$("$@" 2>&1 | indent_section_output)
        exit_code=$?
        set +o pipefail
        echo "$output"
        return $exit_code
    else
        # Run silently but capture errors for display on failure
        local output
        local exit_code
        set -o pipefail
        output=$("$@" 2>&1)
        exit_code=$?
        set +o pipefail
        if [[ $exit_code -eq 0 ]]; then
            # Show success message if verbosity >= normal (not quiet)
            if [[ -n "$success_msg" ]] && [[ $verbosity -ge $VERBOSITY_TACITURN ]]; then
                echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} $success_msg"
            fi
            return 0
        else
            # Show error output even in quiet mode (errors always shown)
            echo "$output" | indent_section_output >&2
            return 1
        fi
    fi
}

# Execute a numbered step with consistent formatting and error handling
# Usage: run_step NUM TITLE VERBOSITY THRESHOLD SUCCESS_MSG ERROR_MSG COMMAND [ARGS...]
run_step() {
    local num="$1"
    local title="$2"
    local verbosity="$3"
    local threshold="$4"
    local success_msg="$5"
    local error_msg="$6"
    shift 6
    # Remaining args are the command

    show_numbered_section "$num" "$title"

    if run_with_verbosity "$verbosity" "$threshold" "$success_msg" "$@"; then
        echo ""
        return 0
    else
        echo ""
        log_error "$error_msg"
        return 1
    fi
}

# Execute a health check section with consistent formatting
# Usage: run_health_check NUM TITLE CHECK_FUNCTION [ARGS...]
# Note: CHECK_FUNCTION can accept verbosity as first argument
run_health_check() {
    local num="$1"
    local title="$2"
    local check_function="$3"
    shift 3
    # Remaining args are passed to check_function

    # Get verbosity from first arg if provided, otherwise default to normal
    local verbosity="${1:-$VERBOSITY_TACITURN}"

    # Skip header in quiet mode
    if [[ $verbosity -ge $VERBOSITY_TACITURN ]]; then
        echo -e " ${BLUE}${num}. ${title}${NC} ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
    fi
    "$check_function" "$@" 2>&1 | indent_section_output
    # Capture exit code from check_function (first command in pipe)
    local result=${PIPESTATUS[0]}
    if [[ $verbosity -ge $VERBOSITY_TACITURN ]]; then
        echo ""
    fi
    return "$result"
}

# Verbose health check (detailed output with unified design)
cmd_health_verbose() {
    local verbosity="${1:-$VERBOSITY_LOQUACIOUS}"

    # Track timing
    local start_time
    start_time=$(date +%s)

    local total_errors=0
    local total_warnings=0

    # Display header with verbosity level indicator (skip in silent mode)
    if [[ $verbosity -ge $VERBOSITY_TACITURN ]]; then
        local verbosity_label="Detailed"
        if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
            verbosity_label="Very Detailed"
        fi

        echo ""
        echo -e "${BLUE}╭──────────────────────────────────────────────────────────╮${NC}"
        echo -e "${BLUE}│${NC}  Dotfiles Health Check ${BLUE}($verbosity_label)${NC}                       ${BLUE}│${NC}"
        echo -e "${BLUE}╰──────────────────────────────────────────────────────────╯${NC}"
        echo ""
    fi

    # 1. Symlink integrity
    echo -e " ${BLUE}1. Symlink Integrity${NC} ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    for package in "${PACKAGES[@]}"; do
        validate_package "$package" "$verbosity" 2>&1 | indent_section_output || ((total_errors++))
    done
    echo ""

    # 2. Configuration syntax
    local syntax_result
    run_health_check "2" "Configuration Syntax" validate_config_syntax "$verbosity" && syntax_result=0 || syntax_result=$?
    ((total_errors += syntax_result))

    # 3. Submodule health
    local submodule_result
    run_health_check "3" "Submodule Health" check_submodule_health && submodule_result=0 || submodule_result=$?
    ((total_errors += submodule_result))

    # 4. Git repository status
    local git_result
    run_health_check "4" "Git Repository" check_git_repo_status && git_result=0 || git_result=$?
    ((total_warnings += git_result))

    # 5. Template/secret config consistency
    local template_result
    run_health_check "5" "Template Consistency" check_template_consistency && template_result=0 || template_result=$?
    ((total_warnings += template_result))

    # 6. File permissions
    local perm_result
    run_health_check "6" "File Permissions" check_file_permissions && perm_result=0 || perm_result=$?
    ((total_errors += perm_result))

    # 7. Shell integration
    local shell_result
    run_health_check "7" "Shell Integration" check_shell_integration && shell_result=0 || shell_result=$?
    ((total_warnings += shell_result))

    # 8. Stow conflicts
    local stow_result
    run_health_check "8" "Stow Conflicts" check_stow_conflicts && stow_result=0 || stow_result=$?
    ((total_errors += stow_result))

    # 9. Orphaned symlinks
    run_health_check "9" "Orphaned Symlinks" check_orphaned_symlinks
    # Note: Orphaned symlinks are warnings, not errors

    # 10. Dependencies
    # Pass verbosity level directly to check_dependencies
    if ! run_health_check "10" "Dependencies" check_dependencies "$verbosity"; then
        ((total_errors++))
    fi

    # 11. Backup health
    show_health_check_spinner "11" "Backup Health" "$verbosity"
    local backup_count backup_size_kb
    read -r backup_count backup_size_kb <<< "$(get_backup_stats)"

    if [[ $backup_count -eq 0 ]]; then
        check_statuses+=("pass")
        check_details+=("No backups")
        check_outputs+=("")
        show_health_table_row "11" "Backup Health" "pass" "No backups" "$verbosity"
    else
        check_statuses+=("info")
        check_details+=("$backup_count backups ($((backup_size_kb / KB_TO_MB))MB)")
        check_outputs+=("")
        show_health_table_row "11" "Backup Health" "info" "$backup_count backups ($((backup_size_kb / KB_TO_MB))MB)" "$verbosity"
    fi

    # 12. Manifest validation
    show_health_check_spinner "12" "Manifest Validation" "$verbosity"
    output=$(validate_all_manifests 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("fail")
        check_details+=("Manifest errors")
        check_outputs+=("$output")
        ((total_errors += result))
        show_health_table_row "12" "Manifest Validation" "fail" "Manifest errors" "$verbosity"
    else
        local manifest_count=0
        for package in "${PACKAGES[@]}"; do
            if [[ -f "$PACKAGES_DIR/$package/manifest.toml" ]]; then
                ((manifest_count++))
            fi
        done
        check_statuses+=("pass")
        check_details+=("$manifest_count manifest(s) valid")
        check_outputs+=("")
        show_health_table_row "12" "Manifest Validation" "pass" "$manifest_count manifest(s) valid" "$verbosity"
    fi

    # Calculate duration
    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))

    # Show summary using same format as regular mode
    if [[ $total_errors -eq 0 ]]; then
        show_health_summary "healthy" 0 "$total_warnings" "$duration"
    else
        show_health_summary "unhealthy" "$total_errors" "$total_warnings" "$duration"
    fi

    # Show maintenance items if any
    local backup_count=0
    while IFS= read -r dir; do
        [[ -z "$dir" ]] && continue
        ((backup_count++))
    done < <(get_backup_dirs)

    local orphaned_count=0
    orphaned_count=$(find "$HOME" -maxdepth 1 -type l -name ".*" 2>/dev/null | while IFS= read -r link; do
        [[ -L "$link" ]] && [[ ! -e "$link" ]] && echo 1
    done | wc -l)

    if [[ $orphaned_count -gt 0 || $backup_count -gt 10 ]]; then
        echo ""
        echo -e "${YELLOW}${SYMBOL_WARNING} Maintenance Items:${NC}"

        if [[ $orphaned_count -gt 0 ]]; then
            echo "  • $orphaned_count orphaned symlink(s) (non-critical)"
        fi

        if [[ $backup_count -gt 10 ]]; then
            local backup_size=0
            while IFS= read -r dir; do
                [[ -z "$dir" ]] && continue
                local size
                size=$(du -sk "$dir" 2>/dev/null | cut -f1)
                ((backup_size += size))
            done < <(get_backup_dirs)
            echo "  • $backup_count backups using $((backup_size / KB_TO_MB))MB - run './dot clean' to free space"
        fi
    fi

    echo ""
    show_tip "Run './dot health' for quick summary view"
    echo ""

    # Return appropriate exit code
    if [[ $total_errors -eq 0 ]]; then
        return 0
    else
        return 1
    fi
}

# Sync package files to system (for copy-sync packages)
# Generic function that works for any package with method = "copy-sync"
sync_package_to_system() {
    local package="$1"

    if [[ -z "$package" ]]; then
        log_error "Package name required"
        return 1
    fi

    if ! load_package_manifest "$package"; then
        log_error "Package '$package' missing manifest: $PACKAGES_DIR/$package/manifest.toml"
        return 1
    fi

    # Only copy-sync packages support sync
    if [[ "$PACKAGE_METHOD" != "copy-sync" ]]; then
        log_error "Package '$package' does not support sync (method: $PACKAGE_METHOD)"
        log_info "Only packages with method = 'copy-sync' support sync operations"
        return 1
    fi

    local source_dir="$PACKAGES_DIR/$package"
    local target_dir="$PACKAGE_TARGET"

    if [[ ! -d "$source_dir" ]]; then
        log_error "Package directory not found: $source_dir"
        return 1
    fi

    # Create target directory if it doesn't exist
    if [[ ! -d "$target_dir" ]]; then
        log_warning "Target directory not found, creating: $target_dir"
        mkdir -p "$target_dir" || {
            log_error "Failed to create target directory: $target_dir"
            return 1
        }
    fi

    # Parse files array
    local files_string="$PACKAGE_FILES"
    IFS=',' read -ra files <<< "$files_string"

    local synced_count=0
    local failed_count=0

    for file in "${files[@]}"; do
        # Remove quotes and whitespace
        file=$(trim_quotes_and_whitespace "$file")

        local source_file="$source_dir/$file"
        local target_file="$target_dir/$file"

        if [[ ! -f "$source_file" ]]; then
            log_warning "Source file not found: $file (skipping)"
            continue
        fi

        # Create target directory structure if needed
        local target_file_dir
        target_file_dir=$(dirname "$target_file")
        if [[ ! -d "$target_file_dir" ]]; then
            mkdir -p "$target_file_dir" || {
                log_error "Failed to create directory: $target_file_dir"
                ((failed_count++))
                continue
            }
        fi

        if cp "$source_file" "$target_file" 2>/dev/null; then
            log_success "Synced $file"
            ((synced_count++))
        else
            log_error "Failed to sync $file"
            ((failed_count++))
        fi
    done

    if [[ $failed_count -gt 0 ]]; then
        log_error "Failed to sync $failed_count file(s)"
        return 1
    fi

    if [[ $synced_count -eq 0 ]]; then
        log_warning "No files synced"
        return 1
    fi

    log_success "Synced $synced_count file(s) successfully"
    # Note: Package-specific tips should be added to package manifests if needed
    return 0
}

# Pull package files from system (for copy-sync packages)
# Generic function that works for any package with method = "copy-sync"
pull_package_from_system() {
    local package="$1"

    if [[ -z "$package" ]]; then
        log_error "Package name required"
        return 1
    fi

    if ! load_package_manifest "$package"; then
        log_error "Package '$package' missing manifest: $PACKAGES_DIR/$package/manifest.toml"
        return 1
    fi

    # Only copy-sync packages support pull
    if [[ "$PACKAGE_METHOD" != "copy-sync" ]]; then
        log_error "Package '$package' does not support pull (method: $PACKAGE_METHOD)"
        log_info "Only packages with method = 'copy-sync' support pull operations"
        return 1
    fi

    local source_dir="$PACKAGE_TARGET"
    local target_dir="$PACKAGES_DIR/$package"

    if [[ ! -d "$source_dir" ]]; then
        log_error "Source directory not found: $source_dir"
        log_info "Expected location: $source_dir"
        return 1
    fi

    # Create target directory if it doesn't exist
    if [[ ! -d "$target_dir" ]]; then
        log_info "Creating package directory: $target_dir"
        mkdir -p "$target_dir" || {
            log_error "Failed to create package directory: $target_dir"
            return 1
        }
    fi

    # Parse files array
    local files_string="$PACKAGE_FILES"
    IFS=',' read -ra files <<< "$files_string"

    local pulled_count=0
    local failed_count=0

    for file in "${files[@]}"; do
        # Remove quotes and whitespace
        file=$(trim_quotes_and_whitespace "$file")

        local source_file="$source_dir/$file"
        local target_file="$target_dir/$file"

        if [[ ! -f "$source_file" ]]; then
            log_warning "Source file not found: $file (skipping)"
            continue
        fi

        # Create target directory structure if needed
        local target_file_dir
        target_file_dir=$(dirname "$target_file")
        if [[ ! -d "$target_file_dir" ]]; then
            mkdir -p "$target_file_dir" || {
                log_error "Failed to create directory: $target_file_dir"
                ((failed_count++))
                continue
            }
        fi

        if cp "$source_file" "$target_file" 2>/dev/null; then
            log_success "Pulled $file"
            ((pulled_count++))
        else
            log_error "Failed to pull $file"
            ((failed_count++))
        fi
    done

    if [[ $failed_count -gt 0 ]]; then
        log_error "Failed to pull $failed_count file(s)"
        return 1
    fi

    if [[ $pulled_count -eq 0 ]]; then
        log_warning "No files pulled"
        return 1
    fi

    log_success "Pulled $pulled_count file(s) successfully"
    show_tips \
        "Review changes: git diff packages/$package" \
        "Commit if satisfied: git add packages/$package && git commit"
    return 0
}

# Remove broken or mispointed dotfile symlinks
# This handles cases where packages were moved (e.g., bash/ -> packages/bash/)
remove_mispointed_symlinks() {
    local verbosity="${1:-$VERBOSITY_TACITURN}"
    local removed_count=0

    # Find all symlinks in $HOME that point to $DOTFILES_DIR
    while IFS= read -r symlink; do
        local target
        target="$(readlink "$symlink")"

        # Check if symlink is broken OR points to wrong location
        if [[ ! -e "$symlink" ]] || [[ "$target" == "$DOTFILES_DIR/"* && "$target" != "$PACKAGES_DIR/"* ]]; then
            if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
                log_info "Removing outdated symlink: ${symlink#"$HOME"/}"
            fi
            rm -f "$symlink"
            ((removed_count++))
        fi
    done < <(find "$HOME" -maxdepth 1 -type l 2>/dev/null)

    # Also check .config directory
    if [[ -d "$HOME/.config" ]]; then
        while IFS= read -r symlink; do
            local target
            target="$(readlink "$symlink")"

            if [[ ! -e "$symlink" ]] || [[ "$target" == *"$DOTFILES_DIR/"* && "$target" != *"$PACKAGES_DIR/"* ]]; then
                if [[ $verbosity -ge $VERBOSITY_GARRULOUS ]]; then
                    log_info "Removing outdated symlink: ${symlink#"$HOME"/}"
                fi
                rm -f "$symlink"
                ((removed_count++))
            fi
        done < <(find "$HOME/.config" -maxdepth 3 -type l 2>/dev/null)
    fi

    if [[ $removed_count -gt 0 && $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
        log_info "Removed $removed_count outdated symlink(s)"
    fi

    return 0
}

# Common installation pipeline
run_installation_pipeline() {
    local verbosity="${1:-$VERBOSITY_TACITURN}"

    # Skip dependency check if environment variable is set (useful for CI)
    if [[ "${SKIP_DEPENDENCY_CHECK:-}" != "true" ]]; then
        if ! check_dependencies "$verbosity"; then
            log_error "Cannot proceed without required dependencies"
            exit 1
        fi
    else
        log_info "Skipping dependency check (SKIP_DEPENDENCY_CHECK=true)"
    fi

    if ! init_submodules; then
        log_error "Submodule initialization failed"
        suggest_fixes "submodules" "$DOTFILES_DIR/.gitmodules"
        return 1
    fi

    if ! process_templates; then
        log_error "Template processing failed"
        return 1
    fi

    if ! merge_secret_configs; then
        log_error "Secret config merging failed"
        return 1
    fi

    if ! install_dotfiles "$verbosity"; then
        log_error "Stow installation failed"
        return 1
    fi

    return 0
}

cmd_update() {
    local verbosity="${1:-$VERBOSITY_TACITURN}"
    local start_time
    start_time=$(date +%s)

    show_command_header "Dotfiles Update"

    # Step 1: Update packages (from manifests)
    show_numbered_section "1" "Update Packages"
    local update_count=0
    local updated_packages=()
    local skipped_packages=()

    for package in "${PACKAGES[@]}"; do
        local manifest="$PACKAGES_DIR/$package/manifest.toml"

        if [[ ! -f "$manifest" ]]; then
            continue
        fi

        # Get update command from manifest
        local update_cmd
        if ! update_cmd=$(get_toml_update_command "$manifest" 2>/dev/null); then
            # No [update] section - skip this package
            continue
        fi

        # Extract command and args from update_cmd (format: "cmd|arg1,arg2,arg3")
        local cmd args_string
        cmd="${update_cmd%%|*}"
        args_string="${update_cmd#*|}"

        # Convert args string to array
        local update_args=()
        if [[ -n "$args_string" ]]; then
            IFS=',' read -ra update_args <<< "$args_string"
        fi

        # Resolve relative paths relative to package directory
        # Absolute paths (starting with /) are passed as-is
        local resolved_args=()
        for arg in "${update_args[@]}"; do
            # Remove quotes and whitespace
            arg=$(trim_quotes_and_whitespace "$arg")

            # If arg is relative path (doesn't start with /), resolve relative to package directory
            if [[ "$arg" != /* ]]; then
                resolved_args+=("$PACKAGES_DIR/$package/$arg")
            else
                resolved_args+=("$arg")
            fi
        done

        # Load package name for display
        if load_package_manifest "$package"; then
            local display_name="$PACKAGE_NAME"
        else
            local display_name="$package"
        fi

        # Show package update
        if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
            log_info "Updating $display_name..."
        fi

        # Execute update command
        if run_package_update "$cmd" "${resolved_args[@]}"; then
            ((update_count++))
            updated_packages+=("$display_name")
            # Show success message at verbosity 1+ (level 2 should show at least what level 1 shows)
            if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
                echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} $display_name updated"
            fi
        else
            skipped_packages+=("$display_name")
            # Show skip message at verbosity 1+ (level 2 should show at least what level 1 shows)
            if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
                echo -e "   ${BLUE}${SYMBOL_INFO}${NC} $display_name already up to date"
            fi
        fi
    done

    if [[ $update_count -eq 0 && ${#updated_packages[@]} -eq 0 && ${#skipped_packages[@]} -eq 0 ]]; then
        # Show message at verbosity 1+ (level 2 should show at least what level 1 shows)
        if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
            echo -e "   ${BLUE}${SYMBOL_INFO}${NC} No packages with update commands"
        fi
    fi
    echo ""

    # Step 2: Clean up outdated symlinks
    if [[ $verbosity -ge $VERBOSITY_LOQUACIOUS ]]; then
        show_numbered_section "2" "Clean Up Outdated Symlinks"
        remove_mispointed_symlinks "$verbosity"
        echo ""
    else
        remove_mispointed_symlinks 0
    fi

    # Step 4: Reinstall
    show_numbered_section "4" "Reinstall Dotfiles"
    if ! run_with_verbosity "$verbosity" $VERBOSITY_LOQUACIOUS "" run_installation_pipeline "$verbosity"; then
        echo ""
        log_error "Installation pipeline failed"
        return 1
    fi

    # Show summary for normal output (level 0, not silent)
    if [[ $verbosity -eq $VERBOSITY_TACITURN ]]; then
        show_installation_summary
    fi
    echo ""

    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))

    show_command_summary "success" "UPDATED" "$duration"
    echo ""

    auto_cleanup_backups

    return 0
}

cmd_status() {
    show_status
}

cmd_diff() {
    show_diff_preview
}

cmd_backup() {
    backup_existing
}

cmd_backups() {
    list_backups
}

cmd_restore() {
    local backup_id="${1:-latest}"
    restore_from_backup "$backup_id"
}

cmd_clean() {
    clean_backups
}

cmd_uninstall() {
    uninstall_dotfiles
}

cmd_enable() {
    local package="$1"
    enable_package "$package"
}

cmd_disable() {
    local package="$1"
    disable_package "$package"
}

cmd_packages() {
    list_packages
}

cmd_security() {
    security_audit
}

cmd_sync() {
    local package="${COMMAND_ARGS[0]:-}"

    if [[ -z "$package" ]]; then
        log_error "Package name required"
        log_info "Usage: ./dot sync <package>"
        log_info "Example: ./dot sync cursor"
        log_info ""
        log_info "Packages that support sync:"
        for pkg in "${PACKAGES[@]}"; do
            if load_package_manifest "$pkg" true && [[ "$PACKAGE_METHOD" == "copy-sync" ]]; then
                log_info "  - $pkg"
            fi
        done
        exit 1
    fi

    sync_package_to_system "$package"
}

cmd_pull() {
    local package="${COMMAND_ARGS[0]:-}"

    if [[ -z "$package" ]]; then
        log_error "Package name required"
        log_info "Usage: ./dot pull <package>"
        log_info "Example: ./dot pull cursor"
        log_info ""
        log_info "Packages that support pull:"
        for pkg in "${PACKAGES[@]}"; do
            if load_package_manifest "$pkg" true && [[ "$PACKAGE_METHOD" == "copy-sync" ]]; then
                log_info "  - $pkg"
            fi
        done
        exit 1
    fi

    pull_package_from_system "$package"
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Main Command Router
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Package Management Functions
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Check if a package is installed
is_package_installed() {
    local package="$1"
    local package_files
    package_files=$(get_package_files "$package")
    # Expand wildcards in file patterns
    package_files=$(expand_file_patterns "$package" "$package_files")

    IFS=',' read -ra files <<< "$package_files"

    # Check if at least one file from the package is a symlink to dotfiles
    for file in "${files[@]}"; do
        local home_file="$HOME/$file"
        if [[ -L "$home_file" ]]; then
            local target
            target=$(readlink "$home_file")
            if [[ "$target" == *".dotfiles/$package/"* ]] || [[ "$target" == "$DOTFILES_DIR/$package/"* ]]; then
                return 0  # Package is installed
            fi
        fi
    done

    return 1  # Package not installed
}

# Enable (install) a specific package
enable_package() {
    local package="$1"

    if [[ -z "$package" ]]; then
        log_error "Package name required"
        log_info "Usage: ./dot enable PACKAGE"
        log_info "Available packages: ${PACKAGES[*]}"
        return 1
    fi

    # Validate package exists
    local package_exists=false
    for pkg in "${PACKAGES[@]}"; do
        if [[ "$pkg" == "$package" ]]; then
            package_exists=true
            break
        fi
    done

    if ! $package_exists; then
        log_error "Unknown package: $package"
        log_info "Available packages: ${PACKAGES[*]}"
        return 1
    fi

    if [[ ! -d "$PACKAGES_DIR/$package" ]]; then
        log_error "Package directory not found: $package"
        return 1
    fi

    # Check if already installed
    if is_package_installed "$package"; then
        log_info "Package already enabled: $package"
        return 0
    fi

    log_info "Enabling package: $package"

    # Install package with stow
    if stow --verbose --restow --dir="$PACKAGES_DIR" --target="$HOME" "$package" 2>&1 | prefix_output "│ "; then
        log_success "Package enabled: $package"
        return 0
    else
        log_error "Failed to enable package: $package"
        return 1
    fi
}

# Disable (uninstall) a specific package
disable_package() {
    local package="$1"

    if [[ -z "$package" ]]; then
        log_error "Package name required"
        log_info "Usage: ./dot disable PACKAGE"
        return 1
    fi

    # Validate package exists
    local package_exists=false
    for pkg in "${PACKAGES[@]}"; do
        if [[ "$pkg" == "$package" ]]; then
            package_exists=true
            break
        fi
    done

    if ! $package_exists; then
        log_error "Unknown package: $package"
        log_info "Available packages: ${PACKAGES[*]}"
        return 1
    fi

    # Check if installed
    if ! is_package_installed "$package"; then
        log_info "Package already disabled: $package"
        return 0
    fi

    log_info "Disabling package: $package"

    # Remove package symlinks with stow
    if stow --verbose --delete --dir="$PACKAGES_DIR" --target="$HOME" "$package" 2>&1 | prefix_output "│ "; then
        log_success "Package disabled: $package"
        return 0
    else
        log_error "Failed to disable package: $package"
        return 1
    fi
}

# List all packages and their installation status
list_packages() {
    show_command_header "Package Management"

    show_section_separator
    echo ""
    printf "  ${BLUE}%-15s %-12s %s${NC}\n" "Package" "Status" "Description"
    echo "  ────────────────────────────────────────────────────────────────"

    for package in "${PACKAGES[@]}"; do
        local status="disabled"
        local symbol="${SYMBOL_ERROR}"
        local color="$RED"

        if is_package_installed "$package"; then
            status="enabled"
            symbol="${SYMBOL_SUCCESS}"
            color="$GREEN"
        fi

        # Get package description
        local description
        description=$(get_package_description "$package")

        printf "  ${color}${symbol}${NC} %-15s %-12s %s\n" "$package" "($status)" "$description"
    done

    echo ""
    show_section_separator
    echo ""
    log_info "Commands:"
    echo "  ${BLUE}./dot enable${NC} ${YELLOW}PACKAGE${NC}   Enable a package"
    echo "  ${BLUE}./dot disable${NC} ${YELLOW}PACKAGE${NC}  Disable a package"
    echo "  ${BLUE}./dot packages${NC}          List packages (this command)"
    echo ""
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Security Audit Functions
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Run security audit on dotfiles
security_audit() {
    show_command_header "Security Audit"

    local issues_found=0

    # 1. Check for accidentally committed secrets
    show_numbered_section "1" "Checking for Committed Secrets"

    # More specific patterns that match actual secrets with values
    # Require actual values (4-8+ chars) after = to reduce false positives
    local patterns=(
        'password\s*=\s*['\''"]?\w{4,}'         # password=value (4+ chars)
        'api[_-]?key\s*=\s*['\''"]?\w{8,}'      # api_key=value (8+ chars)
        'secret\s*=\s*['\''"]?\w{8,}'           # secret=value (8+ chars)
        'token\s*=\s*['\''"]?\w{8,}'            # token=value (8+ chars)
        'private[_-]?key\s*=\s*['\''"]?\w{8,}'  # private_key=value (8+ chars)
        'aws[_-]?access[_-]?key\s*=\s*['\''"]?\w{8,}'  # aws_access_key=value
        'BEGIN\s+(RSA\s+)?PRIVATE\s+KEY'        # Actual private key blocks
    )

    # Build grep args array for single git grep command (performance optimization)
    local grep_args=()
    for pattern in "${patterns[@]}"; do
        grep_args+=("-e" "$pattern")
    done

    local secrets_found="false"
    local matches
    # Exclude docs (may reference patterns) and this function itself
    matches=$(git -C "$DOTFILES_DIR" grep -P -n -i "${grep_args[@]}" -- . \
              ':(exclude)README.md' ':(exclude)AGENTS.md' ':(exclude)DEVELOPMENT.md' \
              ':(exclude)tests/' ':(exclude)dot' 2>/dev/null || true)

    if [[ -n "$matches" ]]; then
        echo -e "   ${YELLOW}${SYMBOL_WARNING}${NC} Potential secret patterns found:"
        while IFS= read -r line; do
            echo "     $line"
        done <<< "$matches"
        echo ""
        secrets_found="true"
        ((issues_found++))
    fi

    if [[ "$secrets_found" == "false" ]]; then
        echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} No secret patterns in tracked files"
    fi
    echo ""

    # 2. Check file permissions on secret files
    show_numbered_section "2" "Checking Secret File Permissions"

    # Collect secret files once to avoid duplicate find operations
    local secret_files=()
    while IFS= read -r f; do
        secret_files+=("$f")
    done < <(find "$DOTFILES_DIR" -name "*.secret" -type f 2>/dev/null)


    local insecure_files=()

    for secret_file in "${secret_files[@]}"; do
        [[ -z "$secret_file" ]] && continue
        local perms
        perms=$(stat -c "%a" "$secret_file" 2>/dev/null || stat -f "%OLp" "$secret_file" 2>/dev/null || echo "000")
        perms=${perms: -3}

        if [[ "$perms" != "600" ]] && [[ "$perms" != "400" ]]; then
            insecure_files+=("$secret_file ($perms)")
            ((issues_found++))
        fi
    done < <(find "$DOTFILES_DIR" -name "*.secret" -type f 2>/dev/null)

    if [[ ${#insecure_files[@]} -gt 0 ]]; then
        echo -e "   ${YELLOW}${SYMBOL_WARNING}${NC} Insecure permissions on secret files:"
        for file in "${insecure_files[@]}"; do
            echo -e "     ${SYMBOL_WARNING} ${file#"$DOTFILES_DIR"/}"
        done
        echo -e "   ${BLUE}${SYMBOL_INFO}${NC} Fix with: chmod 600 FILE (or 400)"
    else
        echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} All secret files have secure permissions"
    fi
    echo ""

    # 3. Check .gitignore coverage
    show_numbered_section "3" "Checking .gitignore Coverage"


    local unignored_secrets=()
    local untracked_unignored=()
    for secret_file in "${secret_files[@]}"; do
        [[ -z "$secret_file" ]] && continue
        # Compute relative path for git commands
        local rel_path="${secret_file#"$DOTFILES_DIR"/}"
        if git -C "$DOTFILES_DIR" check-ignore -q -- "$rel_path" 2>/dev/null; then
            : # properly ignored
        else
            # Check if file is tracked
            if git -C "$DOTFILES_DIR" ls-files --error-unmatch -- "$rel_path" >/dev/null 2>&1; then
                unignored_secrets+=("$secret_file")
                ((issues_found++))
            else
                # Untracked but not ignored - potential future commit risk
                untracked_unignored+=("$secret_file")
                ((issues_found++))
            fi
        fi
    done

    if [[ ${#unignored_secrets[@]} -gt 0 ]]; then
        echo -e "   ${RED}${SYMBOL_ERROR}${NC} Secret files tracked in git:"
        for file in "${unignored_secrets[@]}"; do
            echo -e "     ${SYMBOL_ERROR} ${file#"$DOTFILES_DIR"/}"
        done
        echo -e "   ${RED}${SYMBOL_ERROR}${NC} These files are committed to git!"
        echo ""
    fi

    if [[ ${#untracked_unignored[@]} -gt 0 ]]; then
        echo -e "   ${YELLOW}${SYMBOL_WARNING}${NC} Secret files not ignored by git:"
        for file in "${untracked_unignored[@]}"; do
            echo -e "     ${SYMBOL_WARNING} ${file#"$DOTFILES_DIR"/}"
        done
        echo -e "   ${YELLOW}${SYMBOL_WARNING}${NC} Add patterns to .gitignore to prevent future commits"
        echo ""
    fi

    if [[ ${#unignored_secrets[@]} -eq 0 ]] && [[ ${#untracked_unignored[@]} -eq 0 ]]; then
        echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} All secret files properly ignored"
    fi
    echo ""
    # 4. Check SSH key security
    show_numbered_section "4" "Checking SSH Key Security"

    if [[ -d "$HOME/.ssh" ]]; then
        local exposed_keys=()

        shopt -s nullglob
        for key in "$HOME/.ssh"/id_* "$HOME/.ssh"/*.pem; do
            [[ ! -f "$key" ]] && continue
            [[ "$key" == *.pub ]] && continue

            local perms
            perms=$(stat -c "%a" "$key" 2>/dev/null || stat -f "%OLp" "$key" 2>/dev/null || echo "000")
            perms=${perms: -3}

            if [[ "$perms" != "600" ]] && [[ "$perms" != "400" ]]; then
                exposed_keys+=("$(basename "$key") ($perms)")
                ((issues_found++))
            fi
        done
        shopt -u nullglob

        if [[ ${#exposed_keys[@]} -gt 0 ]]; then
            echo -e "   ${YELLOW}${SYMBOL_WARNING}${NC} Insecure SSH key permissions:"
            for key in "${exposed_keys[@]}"; do
                echo -e "     ${SYMBOL_WARNING} $key"
            done
            echo -e "   ${BLUE}${SYMBOL_INFO}${NC} Fix with: chmod 600 ~/.ssh/KEYFILE (or 400)"
        else
            echo -e "   ${GREEN}${SYMBOL_SUCCESS}${NC} SSH keys have secure permissions"
        fi
    else
        echo -e "   ${BLUE}${SYMBOL_INFO}${NC} No SSH directory found"
    fi
    echo ""

    # Summary
    show_section_separator
    echo ""
    if [[ $issues_found -eq 0 ]]; then
        log_success "No security issues detected"
        show_command_summary "success" "SECURE" ""
    else
        log_warning "Security audit found $issues_found potential issue(s)"
        show_command_summary "info" "$issues_found ISSUES FOUND" ""
        echo ""
        show_tip "Review and fix security issues before committing"
    fi
    echo ""

    return $issues_found
}
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Argument Parsing Helpers
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Check if argument is a flag (starts with -)
is_flag() {
    [[ $1 == -* ]]
}

# Check if argument is a valid command
is_valid_command() {
    local cmd="$1"
    [[ "$cmd" =~ ^(install|health|update|status|diff|backup|backups|restore|clean|uninstall|enable|disable|packages|security|sync|pull)$ ]]
}

# Parse verbosity flag and return verbosity level
# Handles: -q/--quiet (MUTE), -v/--verbose (LOQUACIOUS), -vv (GARRULOUS)
# Verbosity levels: MUTE (quiet), TACITURN (normal), LOQUACIOUS (verbose), GARRULOUS (very verbose)
# Examples:
#   -q, --quiet      → VERBOSITY_MUTE
#   -v, --verbose    → VERBOSITY_LOQUACIOUS
#   -vv              → VERBOSITY_GARRULOUS
# Note: Multiple flags set the highest level (last one wins)
parse_verbosity() {
    local flag="$1"

    if [[ $flag == "-q" ]] || [[ $flag == "--quiet" ]]; then
        echo "$VERBOSITY_MUTE"
        return 0
    elif [[ $flag == "-v" ]] || [[ $flag == "--verbose" ]]; then
        echo "$VERBOSITY_LOQUACIOUS"
        return 0
    elif [[ $flag =~ ^-vv+$ ]]; then
        # Regex matches at least 2 v's (-vv, -vvv, etc.), so always return GARRULOUS
        echo "$VERBOSITY_GARRULOUS"
        return 0
    fi

    return 1
}

# Exit with error message
die() {
    log_error "$1"
    [[ -n "${2:-}" ]] && show_usage
    exit 1
}

# Parse command-line arguments
# Sets global variables: COMMAND, VERBOSITY, COMMAND_ARGS
# Verbosity levels: MUTE (quiet), TACITURN (normal), LOQUACIOUS (verbose), GARRULOUS (very verbose)
parse_arguments() {
    COMMAND=""
    VERBOSITY=$VERBOSITY_TACITURN
    COMMAND_ARGS=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            # Help
            -h|--help)
                show_usage
                exit 0
                ;;

            # Quiet mode (-q, --quiet)
            -q|--quiet)
                VERBOSITY=$VERBOSITY_MUTE
                shift
                ;;

            # Verbosity (-v, -vv, --verbose)
            -v*|--verbose)
                local level
                if level=$(parse_verbosity "$1"); then
                    # Set verbosity level (last flag wins if multiple specified)
                    VERBOSITY=$level
                    shift
                else
                    die "Invalid verbosity flag: $1" show_usage
                fi
                ;;


            # Deprecated validate command
            validate)
                log_warning "'validate' is deprecated, use 'health' instead"
                COMMAND="health"
                shift
                ;;

            # Valid commands
            install|health|update|status|diff|backup|backups|restore|clean|uninstall|enable|disable|packages|security|sync|pull|completion)
                if [[ -n "$COMMAND" ]]; then
                    die "Multiple commands specified: '$COMMAND' and '$1'"
                fi
                COMMAND="$1"
                shift
                # Collect remaining arguments for commands that need them
                while [[ $# -gt 0 ]]; do
                    COMMAND_ARGS+=("$1")
                    shift
                done
                ;;
            # Unknown option (unknown flag)
            -*)
                die "Unknown option: $1" show_usage
                ;;
            # Unknown argument
            *)
                die "Unknown argument: $1" show_usage
                ;;
        esac
    done

    # Default to help if no command
    if [[ -z "$COMMAND" ]]; then
        show_usage
        exit 0
    fi
}

# Handle shell completion requests
handle_completion() {
    local shell="$1"

    # Initialize packages for shells that need dynamic completions (bash, zsh)
    # Fish handles its own dynamic completions internally
    if [[ "$shell" == "bash" ]] || [[ "$shell" == "zsh" ]]; then
        if ! initialize_packages; then
            log_error "Failed to initialize packages for completion"
            return 1
        fi
    fi

    # Output completion file for the specified shell
    local completion_file="$DOTFILES_DIR/completions/dot.$shell"
    if [[ -f "$completion_file" ]]; then
        cat "$completion_file"
    else
        die "Unknown shell type: $shell. Use 'bash', 'zsh', or 'fish'"
    fi
}

# Main script logic
main() {
    # Parse command-line arguments into global COMMAND, VERBOSITY, and COMMAND_ARGS
    parse_arguments "$@"

    # Initialize packages for commands that need them (all except help/completion)
    # This is deferred until after argument parsing to allow --help to work without packages
    if ! initialize_packages; then
        exit 1
    fi

    # Execute command with verbosity level
    case $COMMAND in
        install)
            cmd_install "$VERBOSITY"
            ;;
        health)
            # Health supports verbosity levels: table (0), detailed (1), very detailed (2+)
            cmd_health "$VERBOSITY"
            ;;
        update)
            cmd_update "$VERBOSITY"
            ;;
        status)
            cmd_status
            ;;
        diff)
            cmd_diff
            ;;
        backup)
            cmd_backup
            ;;
        backups)
            cmd_backups
            ;;
        restore)
            # Pass backup ID argument if provided
            cmd_restore "${COMMAND_ARGS[@]}"
            ;;
        clean)
            cmd_clean
            ;;
        uninstall)
            cmd_uninstall
            ;;
        enable)
            # Pass package argument
            cmd_enable "${COMMAND_ARGS[@]}"
            ;;
        disable)
            # Pass package argument
            cmd_disable "${COMMAND_ARGS[@]}"
            ;;
        packages)
            cmd_packages
            ;;
        security)
            cmd_security
            ;;
        sync)
            cmd_sync
            ;;
        pull)
            cmd_pull
            ;;
        completion)
            # Pass shell argument if provided
            if [[ ${#COMMAND_ARGS[@]} -eq 0 ]]; then
                die "Missing shell argument for completion command. Use: completion <bash|zsh|fish>"
            fi
            handle_completion "${COMMAND_ARGS[0]}"
            ;;
        *)
            die "Unknown command: $COMMAND"
            ;;
    esac
}

# Shell completion support
# This section provides completion functions that can be sourced from shell configs
# Usage: source <(dot completion bash) or source <(dot completion zsh)


# Run main function with all arguments
# Skip if being sourced for testing
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
