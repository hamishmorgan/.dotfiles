#!/usr/bin/env bash
# Dotfiles management script
# Compatible with bash 3.2+ (including macOS default bash)
#
# Bash 3.2 Compatibility Notes:
# - Uses functions instead of associative arrays (bash 4+ feature)
# - Uses while-read loops instead of mapfile (bash 4+ feature)
# - Avoids process substitution where possible for portability
# - All array operations use bash 3.2 compatible syntax

# Safer glob handling
shopt -s nullglob      # Empty expansion for non-matching globs
shopt -s extglob       # Extended pattern matching

# Note: Not using 'set -e' for better error handling control
# Errors are explicitly checked and handled with context

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BACKUP_DIR="$DOTFILES_DIR/backups/dotfiles-backup-$(date +%s)"

# Track installation state for rollback
INSTALLED_PACKAGES=()
INSTALLATION_IN_PROGRESS=false
ROLLBACK_STACK=()

# Add action to rollback stack
add_rollback() {
    local action="$1"
    ROLLBACK_STACK+=("$action")
}

# Execute rollback in reverse order
execute_rollback() {
    if [[ ${#ROLLBACK_STACK[@]} -eq 0 ]]; then
        log_info "Nothing to rollback"
        return 0
    fi

    log_warning "Rolling back installation..."

    # Execute in reverse order (LIFO)
    for ((i=${#ROLLBACK_STACK[@]}-1; i>=0; i--)); do
        log_info "Rollback step: ${ROLLBACK_STACK[i]}"
        eval "${ROLLBACK_STACK[i]}" 2>/dev/null || log_warning "Rollback step failed (non-critical)"
    done

    log_success "Rollback completed"
    return 0
}

# Cleanup handler
cleanup_on_exit() {
    local exit_code=$?

    # Only run cleanup if installation was in progress and failed
    if [[ $INSTALLATION_IN_PROGRESS == true ]] && [[ $exit_code -ne 0 ]]; then
        echo ""
        log_error "Installation interrupted or failed (exit code: $exit_code)"

        if [[ ${#ROLLBACK_STACK[@]} -gt 0 ]]; then
            echo ""
            read -p "Rollback installation? (Y/n): " -n 1 -r
            echo ""

            if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
                execute_rollback
            else
                log_info "Skipping rollback"
                if [[ ${#INSTALLED_PACKAGES[@]} -gt 0 ]]; then
                    log_warning "Partial installation: ${INSTALLED_PACKAGES[*]}"
                    log_info "Run './dot uninstall' to remove manually"
                fi
            fi
        fi
    fi
}

# Interrupt handler
handle_interrupt() {
    echo ""
    log_warning "Installation interrupted by user"
    exit 130
}

# Set up traps
trap cleanup_on_exit EXIT
trap handle_interrupt INT TERM

# Package definitions
# Note: system package is stowed first to ensure .stow-global-ignore is in place
PACKAGES=("system" "git" "zsh" "tmux" "gh" "gnuplot" "bash")

# Get package files (bash 3.2 compatible - no associative arrays)
get_package_files() {
    local package="$1"
    case "$package" in
        system)  echo ".stow-global-ignore,.stowrc,.editorconfig,.inputrc" ;;
        git)     echo ".gitconfig,.gitattributes,.gitignore-globals" ;;
        zsh)     echo ".zshrc,.zprofile,.oh-my-zsh" ;;
        tmux)    echo ".tmux.conf" ;;
        gh)      echo ".config/gh" ;;
        gnuplot) echo ".gnuplot" ;;
        bash)    echo ".bashrc,.bash_profile" ;;
        *)       echo "" ;;
    esac
}

# Get package display name (bash 3.2 compatible - no associative arrays)
get_package_name() {
    local package="$1"
    case "$package" in
        system)  echo "System" ;;
        git)     echo "Git" ;;
        zsh)     echo "Zsh" ;;
        tmux)    echo "Tmux" ;;
        gh)      echo "GitHub CLI" ;;
        gnuplot) echo "GNU Plot" ;;
        bash)    echo "Bash" ;;
        *)       echo "$package" ;;
    esac
}

# Get required dependencies (bash 3.2 compatible - no associative arrays)
get_required_deps() {
    local type="$1"
    case "$type" in
        common)   echo "stow git" ;;
        optional) echo "tmux zsh" ;;
        *)        echo "" ;;
    esac
}

# Auto-discovery functions for templates and secret configs
# Convention: *.template files are processed to create target files
# Convention: *.secret files are merged with targets based on file type

# Discover all template files and output template:target pairs
discover_templates() {
    find "$DOTFILES_DIR" -type f -name "*.template" 2>/dev/null | while read -r template; do
        local target="${template%.template}"
        local package_dir
        package_dir=$(dirname "$template")
        local rel_path="${target#"$package_dir"/}"

        echo "$template:$rel_path"
    done | sort
}

# Discover all secret config files
discover_secret_configs() {
    find "$DOTFILES_DIR" -type f -name "*.secret" 2>/dev/null | sort
}

# Logging functions
log_info() {
    echo -e "${BLUE}●${NC} $1"
}

log_success() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1"
}

# Prefix subcommand output for clarity with smart colorization
# Colors lines based on content patterns (errors, warnings, info)
prefix_output() {
    local prefix="${1:-│ }"
    while IFS= read -r line; do
        # Skip harmless stow BUG warnings about absolute path mismatches
        if [[ "$line" =~ "BUG in find_stowed_path? Absolute/relative mismatch" ]]; then
            continue
        fi

        # Pattern matching for line classification
        if [[ "$line" =~ ^[[:space:]]*(ERROR|error|Error|FAIL|fail|failed|Failed|cannot|Cannot|unable|Unable|fatal|Fatal|FATAL) ]] || \
           [[ "$line" =~ (error:|failed:|fatal:) ]]; then
            # Error patterns - red
            echo -e "${RED}${prefix}${line}${NC}"
        elif [[ "$line" =~ ^[[:space:]]*(WARN|warn|Warn|WARNING|warning|Warning|BUG) ]] || \
             [[ "$line" =~ (warning:|warn:) ]]; then
            # Warning patterns - yellow
            echo -e "${YELLOW}${prefix}${line}${NC}"
        elif [[ "$line" =~ ^[[:space:]]*(SUCCESS|success|Success|OK|ok|Ok|DONE|done|Done|✓|✔) ]] || \
             [[ "$line" =~ (success:|complete:|completed:) ]]; then
            # Success patterns - green
            echo -e "${GREEN}${prefix}${line}${NC}"
        else
            # Info/normal output - blue (subtle)
            echo -e "${BLUE}${prefix}${NC}${line}"
        fi
    done
}

# Show usage information
show_usage() {
    echo "Usage: $0 COMMAND [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  install       Install dotfiles using GNU Stow"
    echo "  status        Show installation status and recent backups"
    echo "  health        Run comprehensive diagnostics"
    echo "  update        Update configurations and reinstall"
    echo "  uninstall     Remove dotfiles symlinks"
    echo "  backup        Create backup of existing files"
    echo "  clean         Clean up backup directories"
    echo ""
    echo "Options:"
    echo "  -h, --help           Show this help message"
    echo "  -v, --verbose        Enable verbose output"
    echo "  --completion SHELL   Output shell completion script (bash or zsh)"
    echo ""
    echo "Examples:"
    echo "  $0 install           # Install dotfiles"
    echo "  $0 status            # Quick status check"
    echo "  $0 health            # Full diagnostics"
    echo "  $0 update            # Update and reinstall"
    echo ""
    echo "Quick reference:"
    echo "  status = Quick overview (symlinks + backups)"
    echo "  health = Comprehensive diagnostics (table format by default)"
    echo "  health -v = Detailed output for troubleshooting"
    echo ""
    echo "Shell Integration:"
    echo "  # In .bashrc or .zshrc:"
    echo "  source <($0 --completion bash)  # for bash"
    echo "  source <($0 --completion zsh)   # for zsh"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Portable timeout function (works on Linux and macOS)
# Uses GNU timeout if available, otherwise falls back to Perl
portable_timeout() {
    local duration="$1"
    shift

    if command_exists timeout; then
        timeout "$duration" "$@"
    elif command_exists perl; then
        # Perl-based timeout (portable, available on macOS)
        perl -e 'alarm shift; exec @ARGV' "$duration" "$@"
    else
        # No timeout available, run command normally
        "$@"
    fi
}

# Check dependencies
check_dependencies() {
    log_info "Checking dependencies..."

    local missing_deps=()
    local all_deps
    all_deps="$(get_required_deps common) $(get_required_deps optional)"

    for dep in $all_deps; do
        if ! command_exists "$dep"; then
            missing_deps+=("$dep")
        fi
    done

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing_deps[*]}"
        echo ""
        echo "Install missing dependencies:"
        echo "  Ubuntu/Debian: sudo apt-get install ${missing_deps[*]}"
        echo "  macOS: brew install ${missing_deps[*]}"
        echo "  CentOS/RHEL: sudo yum install ${missing_deps[*]}"
        echo "  Fedora: sudo dnf install ${missing_deps[*]}"
        exit 1
    fi

    log_success "All dependencies satisfied"
}

# Detect platform
detect_platform() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "linux"
    else
        echo "unknown"
    fi
}


# Determine merge strategy based on file type
determine_merge_strategy() {
    local target="$1"

    case "$target" in
        */.gitconfig*|*.gitconfig)
            echo "git-merge"
            ;;
        */hosts.yml|*/hosts.yaml)
            echo "yaml-replace"
            ;;
        *.yml|*.yaml)
            echo "yaml-append"
            ;;
        *)
            echo "replace"
            ;;
    esac
}

# Create backup of existing files
backup_existing() {
    log_info "Creating backup of existing files..."

    # Create backup directory
    if ! mkdir -p "$BACKUP_DIR"; then
        log_error "Failed to create backup directory: $BACKUP_DIR"
        suggest_fixes "backup" "$BACKUP_DIR"
        return 1
    fi

    local backed_up=0

    # Generate backup list dynamically from package definitions
    for package in "${PACKAGES[@]}"; do
        local files
        files=$(get_package_files "$package")
        IFS=',' read -ra file_array <<< "$files"

        for file in "${file_array[@]}"; do
        if [[ -e "$HOME/$file" ]]; then
            log_info "Backing up $file"
            if [[ -d "$HOME/$file" ]]; then
                if ! cp -r "$HOME/$file" "$BACKUP_DIR/" 2>/dev/null; then
                    log_error "Failed to copy directory $file"
                    suggest_fixes "backup" "$HOME/$file"
                    return 1
                fi
            else
                if ! cp "$HOME/$file" "$BACKUP_DIR/" 2>/dev/null; then
                    log_error "Failed to copy file $file"
                    suggest_fixes "backup" "$HOME/$file"
                    return 1
                fi
            fi
            # Remove existing file after backup to prevent stow conflicts
            if ! rm -rf "${HOME:?}/$file" 2>/dev/null; then
                log_error "Failed to remove $file"
                suggest_fixes "backup" "$HOME/$file"
                return 1
            fi
            ((backed_up++))
        else
            log_info "File $file does not exist, skipping"
        fi
        done
    done

    if [[ $backed_up -gt 0 ]]; then
        log_success "Backed up $backed_up files to $BACKUP_DIR"
    else
        log_info "No existing files to backup"
    fi

    return 0
}

# Initialize submodules
init_submodules() {
    log_info "Initializing git submodules..."

    if [[ ! -f "$DOTFILES_DIR/.gitmodules" ]]; then
        log_info "No submodules found"
        return 0
    fi

    cd "$DOTFILES_DIR" || {
        log_error "Failed to change to dotfiles directory: $DOTFILES_DIR"
        return 1
    }

    # Use portable timeout (60 seconds)
    if ! portable_timeout 60 git submodule update --init --recursive 2>&1 | prefix_output "│ "; then
        log_error "Failed to initialize git submodules (timeout or git error)"
        log_info "Try running: cd $DOTFILES_DIR && git submodule update --init --recursive"
        return 1
    fi

    log_success "Submodules initialized"
    return 0
}

# Process configuration templates (auto-discovered)
process_templates() {
    log_info "Processing configuration templates..."

    local template_count=0
    local failed_count=0

    # Process all .template files found in dotfiles directory
    while IFS= read -r template; do
        [[ -z "$template" ]] && continue

        local target="${template%.template}"

        if [[ ! -f "$template" ]]; then
            log_warning "Template not found: ${template#"$DOTFILES_DIR"/}"
            ((failed_count++))
            continue
        fi

        if cp "$template" "$target" 2>/dev/null; then
            log_info "Created ${target#"$DOTFILES_DIR"/} from template"
            ((template_count++))
        else
            log_error "Failed to copy template: ${template#"$DOTFILES_DIR"/}"
            suggest_fixes "template" "$template"
            ((failed_count++))
        fi
    done < <(find "$DOTFILES_DIR" -type f -name "*.template" 2>/dev/null | sort)

    if [[ $template_count -eq 0 ]] && [[ $failed_count -eq 0 ]]; then
        log_info "No template files found"
    elif [[ $template_count -gt 0 ]]; then
        log_success "Processed $template_count template(s)"
    fi

    if [[ $failed_count -gt 0 ]]; then
        log_error "Failed to process $failed_count template(s)"
        return 1
    fi

    return 0
}

# Merge git config using git-config command
merge_git_config() {
    local source="$1"
    local target="$2"

    # Read git config output (avoid process substitution hang)
    local config_output
    config_output=$(git -c "core.filemode=false" config --file "$source" --list 2>&1) || {
        log_error "Failed to read git config from: ${source#"$DOTFILES_DIR"/}"
        log_error "Git error: $config_output"
        suggest_fixes "git-config" "$source"
        return 1
    }

    # Apply each line to target
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local key="${line%%=*}"
        local value="${line#*=}"

        if ! git -c "core.filemode=false" config --file "$target" "$key" "$value" 2>/dev/null; then
            log_warning "Failed to set $key in ${target#"$DOTFILES_DIR"/}"
        fi
    done <<< "$config_output"

    return 0
}

# Secure permissions on secret config file
secure_secret_file() {
    local secret="$1"

    if [[ ! -f "$secret" ]]; then
        return 0
    fi

    if ! chmod 600 "$secret" 2>/dev/null; then
        log_warning "Failed to set secure permissions on ${secret#"$DOTFILES_DIR"/}"
        return 1
    fi

    return 0
}

# Merge secret configurations with templates (auto-discovered)
merge_secret_configs() {
    log_info "Merging secret configurations..."

    local merge_count=0
    local failed_count=0

    # Process all .secret files found in dotfiles directory
    while IFS= read -r secret; do
        [[ -z "$secret" ]] && continue
        [[ ! -f "$secret" ]] && continue

        # Set secure permissions on secret file unconditionally
        secure_secret_file "$secret"

        local target="${secret%.secret}"

        if [[ ! -f "$target" ]]; then
            log_warning "Target file not found for ${secret#"$DOTFILES_DIR"/}, skipping"
            continue
        fi

        local merge_type
        merge_type=$(determine_merge_strategy "$target")

        log_info "Merging ${secret#"$DOTFILES_DIR"/} -> ${target#"$DOTFILES_DIR"/} ($merge_type)"

        case "$merge_type" in
            git-merge)
                if merge_git_config "$secret" "$target"; then
                    ((merge_count++))
                else
                    log_error "Failed to merge git config from ${secret#"$DOTFILES_DIR"/}"
                    ((failed_count++))
                fi
                ;;
            yaml-append)
                if {
                    echo ""
                    echo "# Secret configuration"
                    cat "$secret"
                } >> "$target" 2>/dev/null; then
                    ((merge_count++))
                else
                    log_error "Failed to append secret config to ${target#"$DOTFILES_DIR"/}"
                    ((failed_count++))
                fi
                ;;
            yaml-replace|replace)
                if cp "$secret" "$target" 2>/dev/null; then
                    ((merge_count++))
                else
                    log_error "Failed to copy ${secret#"$DOTFILES_DIR"/} to ${target#"$DOTFILES_DIR"/}"
                    ((failed_count++))
                fi
                ;;
            *)
                log_warning "Unknown merge type: $merge_type for ${secret#"$DOTFILES_DIR"/}"
                ((failed_count++))
                ;;
        esac
    done < <(find "$DOTFILES_DIR" -type f -name "*.secret" 2>/dev/null | sort)

    if [[ $merge_count -eq 0 ]] && [[ $failed_count -eq 0 ]]; then
        log_info "No secret configuration files found"
    elif [[ $merge_count -gt 0 ]]; then
        log_success "Merged $merge_count secret config(s)"
    fi

    if [[ $failed_count -gt 0 ]]; then
        log_error "Failed to merge $failed_count secret config(s)"
        return 1
    fi

    return 0
}

# Install dotfiles using Stow with rollback support
install_dotfiles() {
    log_info "Installing dotfiles using Stow..."

    for package in "${PACKAGES[@]}"; do
        if [[ ! -d "$package" ]]; then
            log_warning "Package directory not found: $package, skipping"
            continue
        fi

        log_info "Installing package: $package"

        # Add rollback action before installing
        add_rollback "stow --verbose --delete --dir='$DOTFILES_DIR' --target='$HOME' '$package' 2>/dev/null || true"

        if stow --verbose --restow --dir="$DOTFILES_DIR" --target="$HOME" "$package" 2>&1 | prefix_output "│ "; then
            INSTALLED_PACKAGES+=("$package")
            log_success "Installed $package"
        else
            log_error "Failed to install package: $package"
            suggest_fixes "stow" "$package"
            return 1
        fi
    done

    return 0
}

# Suggest fixes for common errors
suggest_fixes() {
    local operation="$1"
    local context="$2"

    echo ""
    echo "Suggested fixes:"

    case $operation in
        stow)
            echo "  1. Check for conflicting files: ./dot status"
            echo "  2. Remove or backup conflicting files in $HOME"
            echo "  3. Check stow output above for specific conflicts"
            echo "  4. Try: stow --adopt $context (adopts existing files)"
            ;;
        backup)
            echo "  1. Check disk space: df -h $DOTFILES_DIR/backups"
            echo "  2. Check permissions: ls -la $DOTFILES_DIR/backups"
            echo "  3. Clean old backups: ./dot clean"
            ;;
        template)
            echo "  1. Check template exists: ls -la $DOTFILES_DIR/$context"
            echo "  2. Check target directory permissions"
            echo "  3. Verify template file is readable"
            ;;
        git-config)
            echo "  1. Check config syntax: git config --file $context --list"
            echo "  2. Verify file format (key=value)"
            echo "  3. Check for invalid characters or encoding issues"
            ;;
        network)
            echo "  1. Check internet connection: ping -c 1 github.com"
            echo "  2. Check if behind proxy/firewall"
            echo "  3. Try again later or check $context URL manually"
            ;;
        submodules)
            echo "  1. Check git access: git ls-remote $context"
            echo "  2. Verify SSH keys: ssh -T git@github.com"
            echo "  3. Try: cd $DOTFILES_DIR && git submodule update --init --recursive"
            ;;
        *)
            echo "  1. Check logs above for specific error details"
            echo "  2. Run with verbose mode: ./dot install -v"
            echo "  3. Check GitHub issues: https://github.com/hamishmorgan/.dotfiles/issues"
            ;;
    esac
    echo ""
}

# Check if file is properly linked
check_symlink() {
    local file="$1"
    local expected_target="$2"

    if [[ -L "$HOME/$file" ]]; then
        local target
        target=$(readlink "$HOME/$file")
        if [[ "$target" == *"$expected_target"* ]]; then
            log_success "$file is properly linked to $target"
            return 0
        else
            log_warning "⚠ $file is linked to $target (expected $expected_target)"
            return 1
        fi
    elif [[ -d "$HOME/$file" ]]; then
        # Directory exists - check if it contains stow-managed files
        # (Stow creates directories when linking nested structures)
        log_success "$file exists as directory (stow-managed)"
        return 0
    elif [[ -f "$HOME/$file" ]]; then
        log_warning "⚠ $file exists but is not a symlink"
        return 1
    else
        log_error "$file not found"
        return 1
    fi
}

# Generic package validation function
validate_package() {
    local package="$1"
    local display_name
    display_name=$(get_package_name "$package")
    local files
    files=$(get_package_files "$package")

    log_info "Validating $display_name configuration..."

    local errors=0
    IFS=',' read -ra file_array <<< "$files"

    for file in "${file_array[@]}"; do
        if ! check_symlink "$file" ".dotfiles/$package"; then
            ((errors++))
        fi
    done

    if [[ $errors -eq 0 ]]; then
        log_success "$display_name configuration validated successfully"
        return 0
    else
        log_error "$display_name validation failed with $errors errors"
        return 1
    fi
}

# Get list of backup directories
get_backup_dirs() {
    local backup_dirs=()
    for dir in "$DOTFILES_DIR"/backups/dotfiles-backup-*; do
        if [[ -d "$dir" ]]; then
            backup_dirs+=("$dir")
        fi
    done
    printf '%s\n' "${backup_dirs[@]}"
}

# Show installation status
show_status() {
    log_info "Dotfiles installation status:"
    echo ""

    # Generate file list dynamically from package definitions
    for package in "${PACKAGES[@]}"; do
        local files
        files=$(get_package_files "$package")
        IFS=',' read -ra file_array <<< "$files"

        for file in "${file_array[@]}"; do
            if [[ -L "$HOME/$file" ]]; then
                local target
                target=$(readlink "$HOME/$file")
                echo -e "  ${GREEN}✓${NC} $file -> $target"
            elif [[ -d "$HOME/$file" ]]; then
                # Check if directory contains stow-managed files
                local stow_managed=false
                if find "$HOME/$file" -maxdepth 3 -type l -exec readlink {} \; 2>/dev/null | grep -q ".dotfiles/$package"; then
                    stow_managed=true
                fi

                if $stow_managed; then
                    echo -e "  ${GREEN}✓${NC} $file (stow-managed directory)"
                else
                    echo -e "  ${YELLOW}⚠${NC} $file (directory, not stow-managed)"
                fi
            elif [[ -e "$HOME/$file" ]]; then
                echo -e "  ${YELLOW}⚠${NC} $file (exists but not a symlink)"
            else
                echo -e "  ${RED}✗${NC} $file (not found)"
            fi
        done
    done

    echo ""
    log_info "Backup directories:"
    local backup_dirs=()
    while IFS= read -r dir; do
        backup_dirs+=("$dir")
    done < <(get_backup_dirs | sort -r)

    local total_backups=${#backup_dirs[@]}

    if [[ $total_backups -eq 0 ]]; then
        echo "  No backup directories found"
    else
        # Calculate total size of all backups first
        local total_size=0
        for dir in "${backup_dirs[@]}"; do
            local size_kb
            size_kb=$(du -sk "$dir" 2>/dev/null | cut -f1)
            ((total_size += size_kb))
        done

        # Show only the most recent 5 backups
        local show_count=$((total_backups < 5 ? total_backups : 5))

        for ((i=0; i<show_count; i++)); do
            local dir="${backup_dirs[$i]}"
            echo "  $(basename "$dir") ($(du -sh "$dir" | cut -f1))"
        done

        if [[ $total_backups -gt 5 ]]; then
            echo "  ... and $((total_backups - 5)) older backup(s)"
        fi

        echo ""
        echo "  Total: $total_backups backup(s) using $((total_size / 1024))MB"
        if [[ $total_backups -gt 10 ]]; then
            echo "  Run './dot clean' to remove old backups"
        fi
    fi
}

# Get backup age in days
get_backup_age_days() {
    local backup="$1"
    local backup_mtime
    backup_mtime=$(stat -c %Y "$backup" 2>/dev/null || stat -f %m "$backup" 2>/dev/null)
    echo $(( ($(date +%s) - backup_mtime) / 86400 ))
}

# Clean up backup directories
clean_backups() {
    log_info "Cleaning up old backup directories..."

    local backup_dirs=()
    while IFS= read -r dir; do
        backup_dirs+=("$dir")
    done < <(get_backup_dirs | sort -r)

    local total_backups=${#backup_dirs[@]}

    if [[ $total_backups -eq 0 ]]; then
        log_info "No backup directories to clean"
        return 0
    fi

    log_info "Found $total_backups backup(s)"

    # Configuration (can be overridden via environment)
    local keep_count=${BACKUP_KEEP_COUNT:-5}
    local keep_days=${BACKUP_KEEP_DAYS:-30}

    log_info "Retention policy: keep $keep_count most recent OR newer than $keep_days days"
    echo ""

    # Categorize backups
    local -a to_remove=()
    local -a to_keep=()

    for i in "${!backup_dirs[@]}"; do
        local backup="${backup_dirs[$i]}"
        local backup_name
        backup_name=$(basename "$backup")

        # Keep first N backups regardless of age (sorted newest first)
        if [[ $i -lt $keep_count ]]; then
            to_keep+=("$backup")
            continue
        fi

        # For older backups, check age
        local backup_age_days
        backup_age_days=$(get_backup_age_days "$backup")

        if [[ $backup_age_days -gt $keep_days ]]; then
            to_remove+=("$backup")
        else
            to_keep+=("$backup")
        fi
    done

    # Show summary
    if [[ ${#to_remove[@]} -eq 0 ]]; then
        log_success "All backups within retention policy. Nothing to clean."
        return 0
    fi

    echo "Backups to remove (${#to_remove[@]}):"
    for backup in "${to_remove[@]}"; do
        local backup_name
        backup_name=$(basename "$backup")
        local size
        size=$(du -sh "$backup" 2>/dev/null | cut -f1)
        local age_days
        age_days=$(get_backup_age_days "$backup")
        echo "  - $backup_name ($size, ${age_days}d old)"
    done

    echo ""
    echo "Backups to keep (${#to_keep[@]}):"
    for backup in "${to_keep[@]}"; do
        local backup_name
        backup_name=$(basename "$backup")
        local size
        size=$(du -sh "$backup" 2>/dev/null | cut -f1)
        echo "  - $backup_name ($size)"
    done

    echo ""
    read -p "Remove ${#to_remove[@]} old backup(s)? (y/N): " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Backup cleanup cancelled"
        return 0
    fi

    # Remove old backups
    local removed_count=0
    local freed_space=0

    for backup in "${to_remove[@]}"; do
        local backup_name
        backup_name=$(basename "$backup")
        local size_kb
        size_kb=$(du -sk "$backup" 2>/dev/null | cut -f1)

        if rm -rf "$backup" 2>/dev/null; then
            log_success "Removed $backup_name"
            ((removed_count++))
            ((freed_space += size_kb))
        else
            log_error "Failed to remove $backup_name"
        fi
    done

    echo ""
    log_success "Removed $removed_count backup(s)"
    log_info "Freed $((freed_space / 1024))MiB of disk space"

    return 0
}

# Uninstall dotfiles
uninstall_dotfiles() {
    log_info "Uninstalling dotfiles..."

    for package in "${PACKAGES[@]}"; do
        if [[ -d "$package" ]]; then
            log_info "Uninstalling package: $package"
            stow --verbose --delete --dir="$DOTFILES_DIR" --target="$HOME" "$package" 2>&1 | prefix_output "│ "
            log_success "Uninstalled $package"
        fi
    done

    log_success "Dotfiles uninstalled"
}

# Main command handlers
cmd_install() {
    log_info "Starting dotfiles installation..."
    INSTALLATION_IN_PROGRESS=true

    log_info "Step 1: Backing up existing files..."
    if ! backup_existing; then
        log_error "Backup failed - aborting installation"
        log_info "Backup directory: $BACKUP_DIR"
        INSTALLATION_IN_PROGRESS=false
        return 1
    fi

    log_info "Step 2: Running installation pipeline..."
    if ! run_installation_pipeline; then
        log_error "Installation pipeline failed"
        log_info "Run './dot health' to check installation state"
        INSTALLATION_IN_PROGRESS=false
        return 1
    fi

    INSTALLATION_IN_PROGRESS=false
    log_success "Installation completed successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. Restart your terminal or run: source ~/.zshrc"
    echo "  2. Set zsh as default shell: chsh -s \$(which zsh)"
    echo "  3. Verify installation: $0 health"

    return 0
}


# Validate configuration syntax
validate_config_syntax() {
    log_info "Validating configuration syntax..."

    local errors=0

    # Validate git config
    if [[ -f "$HOME/.gitconfig" ]]; then
        if git config --list >/dev/null 2>&1; then
            log_success "Git configuration syntax valid"
        else
            log_error "Git configuration syntax error"
            ((errors++))
        fi
    fi

    # Validate tmux config
    if [[ -f "$HOME/.tmux.conf" ]]; then
        if command_exists tmux; then
            local tmux_test_session="dotfiles-config-test"
            if tmux -f "$HOME/.tmux.conf" -C new-session -d -s "$tmux_test_session" >/dev/null 2>&1; then
                log_success "Tmux configuration syntax valid"
                # Kill the test session
                tmux kill-session -t "$tmux_test_session" >/dev/null 2>&1 || true
            else
                log_error "Tmux configuration syntax error"
                ((errors++))
            fi
        else
            log_info "Tmux not installed, skipping syntax check"
        fi
    fi

    # Validate zsh config
    if [[ -f "$HOME/.zshrc" ]]; then
        if command_exists zsh; then
            if zsh -n "$HOME/.zshrc" 2>/dev/null; then
                log_success "Zsh configuration syntax valid"
            else
                log_error "Zsh configuration syntax error"
                ((errors++))
            fi
        else
            log_info "Zsh not installed, skipping syntax check"
        fi
    fi

    # Validate bash config
    if [[ -f "$HOME/.bashrc" ]]; then
        if bash -n "$HOME/.bashrc" 2>/dev/null; then
            log_success "Bash configuration syntax valid"
        else
            log_error "Bash configuration syntax error"
            ((errors++))
        fi
    fi

    return $errors
}

# Check for orphaned symlinks
check_orphaned_symlinks() {
    log_info "Checking for orphaned symlinks..."

    local orphaned=0

    # Check dotfiles in home directory
    while IFS= read -r link; do
        if [[ -L "$link" ]] && [[ ! -e "$link" ]]; then
            log_warning "Orphaned symlink: ${link#"$HOME"/}"
            ((orphaned++))
        fi
    done < <(find "$HOME" -maxdepth 1 -type l -name ".*" 2>/dev/null)

    # Check .config directory
    if [[ -d "$HOME/.config" ]]; then
        while IFS= read -r link; do
            if [[ -L "$link" ]] && [[ ! -e "$link" ]]; then
                log_warning "Orphaned symlink: ${link#"$HOME"/}"
                ((orphaned++))
            fi
        done < <(find "$HOME/.config" -maxdepth 2 -type l 2>/dev/null)
    fi

    if [[ $orphaned -eq 0 ]]; then
        log_success "No orphaned symlinks found"
    else
        log_warning "Found $orphaned orphaned symlink(s)"
    fi

    return $orphaned
}

# Check backup directory health
check_backup_health() {
    log_info "Checking backup directory health..."

    local backup_count=0
    local total_size=0

    while IFS= read -r dir; do
        [[ -z "$dir" ]] && continue
        ((backup_count++))
        local size
        size=$(du -sk "$dir" 2>/dev/null | cut -f1)
        ((total_size += size))
    done < <(find "$DOTFILES_DIR/backups" -maxdepth 1 -type d -name "dotfiles-backup-*" 2>/dev/null)

    if [[ $backup_count -eq 0 ]]; then
        log_info "No backup directories found"
    else
        log_info "Found $backup_count backup(s) using $((total_size / 1024))MB"

        if [[ $backup_count -gt 10 ]]; then
            log_warning "Consider cleaning old backups: ./dot clean"
        fi
    fi

    return 0
}

# Check submodule health
check_submodule_health() {
    log_info "Checking submodule health..."

    local issues=0

    # Check if .gitmodules exists
    if [[ ! -f "$DOTFILES_DIR/.gitmodules" ]]; then
        log_info "No submodules configured"
        return 0
    fi

    # Check Oh My Zsh submodule
    local omz_path="$DOTFILES_DIR/zsh/.oh-my-zsh"
    if [[ -d "$omz_path" ]]; then
        # Check if submodule is initialized
        if [[ -f "$omz_path/.git" ]] || [[ -d "$omz_path/.git" ]]; then
            # Check for uncommitted changes in submodule
            if git -C "$omz_path" diff-index --quiet HEAD -- 2>/dev/null; then
                log_success "Oh My Zsh submodule is clean"
            else
                log_warning "Oh My Zsh submodule has uncommitted changes"
            fi

            # Check if submodule is detached
            if git -C "$omz_path" symbolic-ref -q HEAD >/dev/null 2>&1; then
                log_success "Oh My Zsh submodule on branch"
            else
                log_info "Oh My Zsh submodule in detached HEAD state (normal)"
            fi
        else
            log_error "Oh My Zsh submodule not initialized"
            log_info "Run: git submodule update --init --recursive"
            ((issues++))
        fi
    else
        log_error "Oh My Zsh directory missing"
        ((issues++))
    fi

    return $issues
}

# Check git repository status
check_git_repo_status() {
    log_info "Checking dotfiles repository status..."

    local issues=0

    # Check if in a git repository
    if ! git -C "$DOTFILES_DIR" rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not in a git repository"
        return 1
    fi

    # Check for uncommitted changes
    if git -C "$DOTFILES_DIR" diff-index --quiet HEAD -- 2>/dev/null; then
        log_success "Working directory clean"
    else
        log_warning "Working directory has uncommitted changes"
        local changed_count
        changed_count=$(git -C "$DOTFILES_DIR" status --porcelain | wc -l)
        log_info "  $changed_count file(s) modified"
    fi

    # Check current branch
    local current_branch
    current_branch=$(git -C "$DOTFILES_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null)
    log_info "Current branch: $current_branch"

    # Check if branch has upstream
    if git -C "$DOTFILES_DIR" rev-parse --abbrev-ref '@{upstream}' >/dev/null 2>&1; then
        # Check if up to date with remote
        git -C "$DOTFILES_DIR" fetch origin "$current_branch" --dry-run 2>/dev/null
        local ahead
        local behind
        ahead=$(git -C "$DOTFILES_DIR" rev-list --count '@{upstream}..HEAD' 2>/dev/null || echo "0")
        behind=$(git -C "$DOTFILES_DIR" rev-list --count 'HEAD..@{upstream}' 2>/dev/null || echo "0")

        if [[ $ahead -eq 0 ]] && [[ $behind -eq 0 ]]; then
            log_success "Up to date with origin"
        elif [[ $ahead -gt 0 ]] && [[ $behind -eq 0 ]]; then
            log_warning "Branch is ahead of origin by $ahead commit(s)"
            log_info "  Consider: git push"
        elif [[ $ahead -eq 0 ]] && [[ $behind -gt 0 ]]; then
            log_warning "Branch is behind origin by $behind commit(s)"
            log_info "  Consider: git pull"
            ((issues++))
        else
            log_warning "Branch has diverged ($ahead ahead, $behind behind)"
            log_info "  Consider: git pull --rebase"
            ((issues++))
        fi
    else
        log_info "No upstream branch configured"
    fi

    return $issues
}

# Check template and secret config consistency
check_template_consistency() {
    log_info "Checking template/secret config consistency..."

    local issues=0

    # Discover templates
    local template_list
    template_list=$(discover_templates)

    if [[ -z "$template_list" ]]; then
        log_info "No templates configured"
        return 0
    fi

    # Check each template
    while IFS=: read -r template target; do
        [[ -z "$template" ]] && continue

        local secret="${template%.template}.secret"
        local package_dir
        package_dir=$(dirname "$template")
        local target_file="$HOME/$target"

        # Check if secret config exists
        if [[ ! -f "$secret" ]]; then
            log_warning "Template without secret config: ${template#"$DOTFILES_DIR"/}"
            log_info "  Consider creating: ${secret#"$DOTFILES_DIR"/}"
        fi

        # Check if merged file is stale
        if [[ -f "$target_file" ]] && [[ -f "$secret" ]]; then
            if [[ "$template" -nt "$target_file" ]] || [[ "$secret" -nt "$target_file" ]]; then
                log_warning "Stale merged config: ${target_file#"$HOME"/}"
                log_info "  Source files newer than target. Run: ./dot install"
                ((issues++))
            else
                log_success "${target} up to date"
            fi
        fi
    done <<< "$template_list"

    # Check for orphaned secret configs
    while IFS= read -r secret; do
        [[ -z "$secret" ]] && continue

        local template="${secret%.secret}.template"
        if [[ ! -f "$template" ]]; then
            log_warning "Secret config without template: ${secret#"$DOTFILES_DIR"/}"
        fi
    done < <(discover_secret_configs)

    return $issues
}

# Check file permissions
check_file_permissions() {
    log_info "Checking file permissions..."

    local errors=0
    local warnings=0

    # Check secret config files (should not be world-readable)
    while IFS= read -r secret; do
        [[ -z "$secret" ]] && continue
        [[ ! -f "$secret" ]] && continue

        local perms
        perms=$(stat -c '%a' "$secret" 2>/dev/null || stat -f '%A' "$secret" 2>/dev/null)

        # Check if world-readable (last digit > 0)
        if [[ "${perms: -1}" != "0" ]]; then
            log_warning "Secret config is world-readable: ${secret#"$DOTFILES_DIR"/}"
            log_info "  Consider: chmod 600 $secret"
            ((warnings++))
        else
            log_success "${secret#"$DOTFILES_DIR"/} has secure permissions"
        fi
    done < <(discover_secret_configs)

    # Check for accidentally committed secrets (this is an ERROR not a warning)
    if [[ -f "$DOTFILES_DIR/git/.gitconfig.secret" ]]; then
        if git -C "$DOTFILES_DIR" ls-files --error-unmatch "git/.gitconfig.secret" >/dev/null 2>&1; then
            log_error "Secret git config is tracked by git (potential secrets leak)"
            log_info "  Run: git rm --cached git/.gitconfig.secret"
            ((errors++))
        else
            log_success "Secret configs properly ignored by git"
        fi
    fi

    if [[ $warnings -gt 0 ]]; then
        log_info "Found $warnings permission warning(s) - consider fixing for better security"
    fi

    return $errors
}

# Check shell integration
check_shell_integration() {
    log_info "Checking shell integration..."

    local issues=0

    # Check if we're actually using our shell configs
    if [[ -n "$ZSH_VERSION" ]]; then
        if [[ -L "$HOME/.zshrc" ]]; then
            local target
            target=$(readlink "$HOME/.zshrc")
            if [[ "$target" == *".dotfiles"* ]]; then
                log_success "Using dotfiles .zshrc"
            else
                log_warning "Shell config symlink points elsewhere: $target"
                ((issues++))
            fi
        else
            log_error ".zshrc is not a symlink to dotfiles"
            ((issues++))
        fi
    elif [[ -n "$BASH_VERSION" ]]; then
        if [[ -L "$HOME/.bashrc" ]]; then
            local target
            target=$(readlink "$HOME/.bashrc")
            if [[ "$target" == *".dotfiles"* ]]; then
                log_success "Using dotfiles .bashrc"
            else
                log_warning "Shell config symlink points elsewhere: $target"
                ((issues++))
            fi
        else
            log_error ".bashrc is not a symlink to dotfiles"
            ((issues++))
        fi
    fi

    # Check PATH includes our custom directories
    if [[ ":$PATH:" == *":$HOME/bin:"* ]] || [[ ":$PATH:" == *":$HOME/.local/bin:"* ]]; then
        log_success "Custom bin directories in PATH"
    else
        log_warning "Custom bin directories not in PATH"
        log_info "  Expected: ~/bin or ~/.local/bin in PATH"
    fi

    # Check if dotfiles repo is in expected location
    if [[ "$DOTFILES_DIR" == "$HOME/.dotfiles" ]]; then
        log_success "Dotfiles in standard location"
    else
        log_info "Dotfiles location: $DOTFILES_DIR (non-standard)"
    fi

    return $issues
}

# Check for stow conflicts
check_stow_conflicts() {
    log_info "Checking for potential stow conflicts..."

    local issues=0

    # Check each package for potential conflicts
    for package in "${PACKAGES[@]}"; do
        local package_dir="$DOTFILES_DIR/$package"
        [[ ! -d "$package_dir" ]] && continue

        # Find all files in package
        while IFS= read -r file; do
            [[ -z "$file" ]] && continue

            local rel_path="${file#"$package_dir"/}"
            local target_path="$HOME/$rel_path"

            # Skip if it's already our symlink
            if [[ -L "$target_path" ]]; then
                local link_target
                link_target=$(readlink "$target_path")
                if [[ "$link_target" == *".dotfiles/$package"* ]]; then
                    continue
                fi
            fi

            # Check if target exists but is not our symlink
            if [[ -e "$target_path" ]] && [[ ! -L "$target_path" ]]; then
                log_warning "Unmanaged file would conflict: $rel_path"
                log_info "  File exists but not managed by stow"
                ((issues++))
            fi
        done < <(find "$package_dir" -type f -not -path "*/.*" 2>/dev/null)
    done

    if [[ $issues -eq 0 ]]; then
        log_success "No stow conflicts detected"
    fi

    return $issues
}

# Display table header
show_health_table_header() {
    echo ""
    echo -e "${BLUE}╭──────────────────────────────────────────────────────────╮${NC}"
    echo -e "${BLUE}│${NC}  Dotfiles Health Check                                   ${BLUE}│${NC}"
    echo -e "${BLUE}╰──────────────────────────────────────────────────────────╯${NC}"
    echo ""
    printf " %-28s %-12s %s\n" "Category" "Status" "Details"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# Display table row with spinner
show_health_check_spinner() {
    local num="$1"
    local category="$2"
    
    # Show spinner - ⠿ is a wide character (2 cols)
    printf " %2s %-25s ${BLUE}⠿ Checking...${NC}\r" "$num." "$category"  # Right-align number
}

# Display table row
show_health_table_row() {
    local num="$1"
    local category="$2"
    local status="$3"
    local details="$4"

    local status_text
    local status_color
    case "$status" in
        pass)
            status_text="✓ Pass"
            status_color="$GREEN"
            ;;
        fail)
            status_text="✗ Fail"
            status_color="$RED"
            ;;
        warn)
            status_text="⚠ Warn"
            status_color="$YELLOW"
            ;;
        info)
            status_text="ℹ Info"
            status_color="$BLUE"
            ;;
    esac

    # Clear the spinner line and show result
    # Note: Emoji chars (✓✗⚠ℹ) are wide (2 cols each), but text is: "X Pass/Fail/Warn/Info"
    # "✓ Pass" visually = 2+1+4 = 7 cols, need 12 total = 5 more spaces
    # "⚠ Warn" visually = 2+1+4 = 7 cols, need 12 total = 5 more spaces
    # "ℹ Info" visually = 2+1+4 = 7 cols, need 12 total = 5 more spaces
    # "✗ Fail" visually = 2+1+4 = 7 cols, need 12 total = 5 more spaces
    printf "\r\033[K %2s %-25s " "$num." "$category"  # Right-align number
    printf "%b%s%b     " "$status_color" "$status_text" "$NC"  # 5 spaces for padding
    printf "%s\n" "$details"
}

# Display health summary
show_health_summary() {
    local status="$1"
    local error_count="$2"
    local warn_count="$3"
    local duration="$4"

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    if [[ "$status" == "healthy" ]]; then
        # Border = 60 chars total
        # " Result: ✓ HEALTHY" = 1 + 8 + 2 (wide ✓) + 8 = 19 visual cols
        # "Duration: X.Xs" = 14 chars
        # Padding: 60 - 19 - 14 = 27 spaces
        printf " Result: %b✓ HEALTHY%b" "$GREEN" "$NC"
        printf "%27s" ""
        printf "Duration: %.1fs\n" "$duration"
    else
        local issues_text="$error_count error"
        [[ $error_count -ne 1 ]] && issues_text="${issues_text}s"
        if [[ $warn_count -gt 0 ]]; then
            issues_text="$issues_text, $warn_count warning"
            [[ $warn_count -ne 1 ]] && issues_text="${issues_text}s"
        fi
        # " Result: ✗ UNHEALTHY (text)" - calculate padding to fit in 60 chars
        # 1 + 8 + 2 (wide ✗) + 10 ("UNHEALTHY ") + 1 ("(") + text + 1 (")") = 23 + text
        local visible_length=$((23 + ${#issues_text}))
        local padding=$((46 - visible_length))  # 60 - 14 (duration text) = 46 max before duration
        [[ $padding -lt 1 ]] && padding=1
        
        printf " Result: %b✗ UNHEALTHY%b (%s)" "$RED" "$NC" "$issues_text"
        printf "%${padding}s" ""
        printf "Duration: %.1fs\n" "$duration"
    fi
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# Count files/symlinks for a check
count_symlinks() {
    local count=0
    for package in "${PACKAGES[@]}"; do
        local files
        files=$(get_package_files "$package")
        IFS=',' read -ra file_array <<< "$files"
        count=$((count + ${#file_array[@]}))
    done
    echo "$count"
}

# Comprehensive health check command (table format)
cmd_health() {
    local verbose="${1:-false}"

    # If verbose mode, show the old detailed output
    if [[ "$verbose" == "true" ]]; then
        cmd_health_verbose
        return $?
    fi

    # Track timing
    local start_time
    start_time=$(date +%s)

    # Initialize result tracking (bash 3.2 compatible - parallel arrays)
    local check_statuses=()
    local check_details=()
    local check_outputs=()

    local total_errors=0
    local total_warnings=0

    # Display table header immediately
    show_health_table_header

    # Run checks and display results progressively
    local output
    local result

    # 1. Symlink integrity
    show_health_check_spinner "1" "Symlink Integrity"
    output=""
    for package in "${PACKAGES[@]}"; do
        if ! validate_package "$package" >/dev/null 2>&1; then
            output="${output}Package $package validation failed\n"
            ((total_errors++))
        fi
    done

    if [[ -n "$output" ]]; then
        check_statuses+=("fail")
        check_details+=("Validation errors")
        check_outputs+=("$output")
        show_health_table_row "1" "Symlink Integrity" "fail" "Validation errors"
    else
        local file_count
        file_count=$(count_symlinks)
        check_statuses+=("pass")
        check_details+=("$file_count files linked")
        check_outputs+=("")
        show_health_table_row "1" "Symlink Integrity" "pass" "$file_count files linked"
    fi

    # 2. Configuration syntax
    show_health_check_spinner "2" "Configuration Syntax"
    output=$(validate_config_syntax 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("fail")
        check_details+=("Syntax errors")
        check_outputs+=("$output")
        ((total_errors += result))
        show_health_table_row "2" "Configuration Syntax" "fail" "Syntax errors"
    else
        check_statuses+=("pass")
        check_details+=("All configs valid")
        check_outputs+=("")
        show_health_table_row "2" "Configuration Syntax" "pass" "All configs valid"
    fi

    # 3. Submodule health
    show_health_check_spinner "3" "Submodule Health"
    output=$(check_submodule_health 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("fail")
        check_details+=("Issues found")
        check_outputs+=("$output")
        ((total_errors += result))
        show_health_table_row "3" "Submodule Health" "fail" "Issues found"
    else
        check_statuses+=("pass")
        check_details+=("Oh My Zsh clean")
        check_outputs+=("")
        show_health_table_row "3" "Submodule Health" "pass" "Oh My Zsh clean"
    fi

    # 4. Git repository status
    show_health_check_spinner "4" "Git Repository"
    output=$(check_git_repo_status 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("warn")
        check_details+=("Uncommitted changes")
        check_outputs+=("$output")
        ((total_warnings += result))
        show_health_table_row "4" "Git Repository" "warn" "Uncommitted changes"
    else
        check_statuses+=("pass")
        check_details+=("Clean, up-to-date")
        check_outputs+=("")
        show_health_table_row "4" "Git Repository" "pass" "Clean, up-to-date"
    fi

    # 5. Template/secret config consistency
    show_health_check_spinner "5" "Template Consistency"
    output=$(check_template_consistency 2>&1)
    result=$?
    local template_count=0
    template_count=$(discover_templates | wc -l)
    if [[ $result -ne 0 ]]; then
        check_statuses+=("warn")
        check_details+=("Stale configs")
        check_outputs+=("$output")
        ((total_warnings += result))
        show_health_table_row "5" "Template Consistency" "warn" "Stale configs"
    else
        check_statuses+=("pass")
        check_details+=("$template_count template(s) synced")
        check_outputs+=("")
        show_health_table_row "5" "Template Consistency" "pass" "$template_count template(s) synced"
    fi

    # 6. File permissions
    show_health_check_spinner "6" "File Permissions"
    output=$(check_file_permissions 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("fail")
        check_details+=("Insecure permissions")
        check_outputs+=("$output")
        ((total_errors += result))
        show_health_table_row "6" "File Permissions" "fail" "Insecure permissions"
    else
        check_statuses+=("pass")
        check_details+=("Secrets secured")
        check_outputs+=("")
        show_health_table_row "6" "File Permissions" "pass" "Secrets secured"
    fi

    # 7. Shell integration
    show_health_check_spinner "7" "Shell Integration"
    output=$(check_shell_integration 2>&1)
    result=$?
    local shell_name=""
    if [[ -n "$ZSH_VERSION" ]]; then
        shell_name="Zsh"
    elif [[ -n "$BASH_VERSION" ]]; then
        shell_name="Bash"
    fi

    if [[ $result -ne 0 ]]; then
        check_statuses+=("warn")
        check_details+=("Issues detected")
        check_outputs+=("$output")
        ((total_warnings += result))
        show_health_table_row "7" "Shell Integration" "warn" "Issues detected"
    else
        check_statuses+=("pass")
        check_details+=("$shell_name active")
        check_outputs+=("")
        show_health_table_row "7" "Shell Integration" "pass" "$shell_name active"
    fi

    # 8. Stow conflicts
    show_health_check_spinner "8" "Stow Conflicts"
    output=$(check_stow_conflicts 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("fail")
        check_details+=("$result conflict(s)")
        check_outputs+=("$output")
        ((total_errors += result))
        show_health_table_row "8" "Stow Conflicts" "fail" "$result conflict(s)"
    else
        check_statuses+=("pass")
        check_details+=("No conflicts")
        check_outputs+=("")
        show_health_table_row "8" "Stow Conflicts" "pass" "No conflicts"
    fi

    # 9. Orphaned symlinks
    show_health_check_spinner "9" "Orphaned Symlinks"
    output=$(check_orphaned_symlinks 2>&1)
    result=$?
    if [[ $result -ne 0 ]]; then
        check_statuses+=("warn")
        check_details+=("$result found")
        check_outputs+=("$output")
        show_health_table_row "9" "Orphaned Symlinks" "warn" "$result found"
        # Don't count as error, just warning
    else
        check_statuses+=("pass")
        check_details+=("None found")
        check_outputs+=("")
        show_health_table_row "9" "Orphaned Symlinks" "pass" "None found"
    fi

    # 10. Dependencies
    show_health_check_spinner "10" "Dependencies"
    if check_dependencies >/dev/null 2>&1; then
        check_statuses+=("pass")
        check_details+=("All satisfied")
        check_outputs+=("")
        show_health_table_row "10" "Dependencies" "pass" "All satisfied"
    else
        output=$(check_dependencies 2>&1)
        check_statuses+=("fail")
        check_details+=("Missing deps")
        check_outputs+=("$output")
        ((total_errors++))
        show_health_table_row "10" "Dependencies" "fail" "Missing deps"
    fi

    # 11. Backup health
    show_health_check_spinner "11" "Backup Health"
    local backup_count=0
    local backup_size=0
    while IFS= read -r dir; do
        [[ -z "$dir" ]] && continue
        ((backup_count++))
        local size
        size=$(du -sk "$dir" 2>/dev/null | cut -f1)
        ((backup_size += size))
    done < <(get_backup_dirs)

    if [[ $backup_count -eq 0 ]]; then
        check_statuses+=("pass")
        check_details+=("No backups")
        check_outputs+=("")
        show_health_table_row "11" "Backup Health" "pass" "No backups"
    else
        check_statuses+=("info")
        check_details+=("$backup_count backups ($((backup_size / 1024))MB)")
        check_outputs+=("")
        show_health_table_row "11" "Backup Health" "info" "$backup_count backups ($((backup_size / 1024))MB)"
    fi

    # Calculate duration
    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))

    echo ""

    # Show summary
    if [[ $total_errors -eq 0 ]]; then
        show_health_summary "healthy" 0 "$total_warnings" "$duration"
    else
        show_health_summary "unhealthy" "$total_errors" "$total_warnings" "$duration"
    fi

    echo ""

    # Check if we have maintenance items to show
    local has_maintenance=false
    if [[ "${check_statuses[8]}" == "warn" ]] || [[ "${check_statuses[10]}" == "info" && $backup_count -gt 10 ]]; then
        has_maintenance=true
    fi

    # Show detailed issues if any
    if [[ $total_errors -gt 0 ]] || [[ $total_warnings -gt 0 ]] || [[ "$has_maintenance" == "true" ]]; then
        local shown_errors=false
        local shown_warnings=false

        # Show errors first
        for i in "${!check_statuses[@]}"; do
            if [[ "${check_statuses[$i]}" == "fail" ]] && [[ -n "${check_outputs[$i]}" ]]; then
                if [[ "$shown_errors" == "false" ]]; then
                    echo -e "${RED}✗ Critical Issues:${NC}"
                    shown_errors=true
                fi

                local category_name=""
                case $i in
                    0) category_name="Symlink Integrity" ;;
                    1) category_name="Configuration Syntax" ;;
                    2) category_name="Submodule Health" ;;
                    3) category_name="Git Repository" ;;
                    4) category_name="Template Consistency" ;;
                    5) category_name="File Permissions" ;;
                    6) category_name="Shell Integration" ;;
                    7) category_name="Stow Conflicts" ;;
                    8) category_name="Orphaned Symlinks" ;;
                    9) category_name="Dependencies" ;;
                    10) category_name="Backup Health" ;;
                esac

                echo "  $((i + 1)). $category_name"
                echo -e "${check_outputs[$i]}" | sed 's/^/     /'
            fi
        done

        # Show warnings
        for i in "${!check_statuses[@]}"; do
            if [[ "${check_statuses[$i]}" == "warn" ]] && [[ -n "${check_outputs[$i]}" ]]; then
                # Check if there's actually output to display
                local warning_output
                warning_output=$(echo -e "${check_outputs[$i]}" | grep -E "^(⚠|●)")

                if [[ -n "$warning_output" ]]; then
                    if [[ "$shown_warnings" == "false" ]]; then
                        [[ "$shown_errors" == "true" ]] && echo ""
                        echo -e "${YELLOW}⚠ Warnings:${NC}"
                        shown_warnings=true
                    fi

                    # shellcheck disable=SC2001
                    echo "$warning_output" | sed 's/^/  /'
                fi
            fi
        done

        # Show maintenance items
        if [[ "$has_maintenance" == "true" ]]; then
            [[ "$shown_errors" == "true" || "$shown_warnings" == "true" ]] && echo ""
            echo -e "${YELLOW}⚠ Maintenance Items:${NC}"

            if [[ "${check_statuses[8]}" == "warn" ]]; then
                echo "  • ${check_details[8]} orphaned symlinks (non-critical)"
            fi

            if [[ "${check_statuses[10]}" == "info" && $backup_count -gt 10 ]]; then
                echo "  • $backup_count backups using $((backup_size / 1024))MB - run './dot clean' to free space"
            fi
        fi

        # Show quick fix suggestion
        if [[ $total_errors -gt 0 ]]; then
            echo ""
            echo -e "${BLUE}💡 Quick fix: Run './dot install' to resolve most issues${NC}"
        fi
    fi

    echo ""
    echo -e "${BLUE}💡 Tip: Run './dot health -v' for detailed output${NC}"
    echo ""

    # Return appropriate exit code
    if [[ $total_errors -eq 0 ]]; then
        return 0
    else
        return 1
    fi
}

# Verbose health check (original detailed output)
cmd_health_verbose() {
    log_info "Running comprehensive dotfiles health check..."
    echo ""

    local total_issues=0

    # 1. Symlink integrity
    log_info "=== Symlink Integrity ==="
    for package in "${PACKAGES[@]}"; do
        validate_package "$package" || ((total_issues++))
    done
    echo ""

    # 2. Configuration syntax
    log_info "=== Configuration Syntax ==="
    validate_config_syntax || ((total_issues += $?))
    echo ""

    # 3. Submodule health
    log_info "=== Submodule Health ==="
    check_submodule_health || ((total_issues += $?))
    echo ""

    # 4. Git repository status
    log_info "=== Git Repository Status ==="
    check_git_repo_status || ((total_issues += $?))
    echo ""

    # 5. Template/secret config consistency
    log_info "=== Template Configuration Consistency ==="
    check_template_consistency || ((total_issues += $?))
    echo ""

    # 6. File permissions
    log_info "=== File Permissions ==="
    check_file_permissions || ((total_issues += $?))
    echo ""

    # 7. Shell integration
    log_info "=== Shell Integration ==="
    check_shell_integration || ((total_issues += $?))
    echo ""

    # 8. Stow conflicts
    log_info "=== Stow Conflicts ==="
    check_stow_conflicts || ((total_issues += $?))
    echo ""

    # 9. Orphaned symlinks
    log_info "=== Orphaned Symlinks ==="
    check_orphaned_symlinks
    # Note: Orphaned symlinks are warnings, not errors
    echo ""

    # 10. Dependencies
    log_info "=== Dependencies ==="
    if check_dependencies 2>/dev/null; then
        log_success "All dependencies satisfied"
    else
        log_warning "Some dependencies missing (see above)"
        ((total_issues++))
    fi
    echo ""

    # 11. Backup health
    log_info "=== Backup Health ==="
    check_backup_health
    echo ""

    # Summary
    echo "========================================"
    if [[ $total_issues -eq 0 ]]; then
        log_success "Health check passed! No issues found."
        return 0
    else
        log_error "Health check found $total_issues issue(s)"
        log_info "Run './dot install' to fix installation issues"
        return 1
    fi
}

# Update gitignore globals from gitignore.io
update_gitignore() {
    log_info "Updating .gitignore-globals from toptal.com..."

    local types="linux,osx,windows"
    local url="https://www.toptal.com/developers/gitignore/api/$types"
    local gitignore_file="$DOTFILES_DIR/git/.gitignore-globals"

    # Add timeout to prevent hanging (30 seconds)
    if portable_timeout 30 curl -s "$url" > "$gitignore_file.tmp" 2>&1; then
        if [[ -s "$gitignore_file.tmp" ]]; then
            mv "$gitignore_file.tmp" "$gitignore_file"
            log_success "Updated .gitignore-globals with latest patterns"
            return 0
        else
            rm -f "$gitignore_file.tmp"
            log_error "Downloaded file is empty"
            return 1
        fi
    else
        rm -f "$gitignore_file.tmp"
        log_error "Failed to download .gitignore-globals (timeout or network error)"
        suggest_fixes "network" "$url"
        return 1
    fi
}

# Update Oh My Zsh
update_oh_my_zsh() {
    log_info "Checking for Oh My Zsh updates..."

    if command_exists omz; then
        if omz update 2>&1 | prefix_output "│ "; then
            log_success "Oh My Zsh updated successfully"
        else
            log_warning "Oh My Zsh update failed or no updates available"
        fi
    else
        log_warning "Oh My Zsh not available for update"
    fi
}

# Common installation pipeline
run_installation_pipeline() {
    if ! check_dependencies; then
        return 1
    fi

    if ! init_submodules; then
        log_error "Submodule initialization failed"
        suggest_fixes "submodules" "$DOTFILES_DIR/.gitmodules"
        return 1
    fi

    if ! process_templates; then
        log_error "Template processing failed"
        return 1
    fi

    if ! merge_secret_configs; then
        log_error "Secret config merging failed"
        return 1
    fi

    if ! install_dotfiles; then
        log_error "Stow installation failed"
        return 1
    fi

    return 0
}

cmd_update() {
    log_info "Updating dotfiles and configurations..."

    # Update gitignore globals
    update_gitignore

    # Update Oh My Zsh
    update_oh_my_zsh

    # Reinstall to pick up any changes
    run_installation_pipeline

    log_success "Update completed successfully!"
}

cmd_status() {
    show_status
}

cmd_backup() {
    backup_existing
}

cmd_clean() {
    clean_backups
}

cmd_uninstall() {
    uninstall_dotfiles
}

# Main script logic
main() {
    # Parse arguments
    local command=""
    local verbose=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            install|health|update|status|backup|clean|uninstall)
                if [[ -n "$command" ]]; then
                    log_error "Multiple commands specified"
                    exit 1
                fi
                command="$1"
                shift
                ;;
            validate)
                # Deprecated: redirect to health
                log_warning "'validate' is deprecated, use 'health' instead"
                command="health"
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Default to help if no command specified
    if [[ -z "$command" ]]; then
        show_usage
        exit 0
    fi

    # Execute command
    case $command in
        install)
            # Enable verbose output if requested
            if $verbose; then
                set -x
            fi
            cmd_install
            ;;
        health)
            # Pass verbose flag to health command
            if $verbose; then
                cmd_health true
            else
                cmd_health false
            fi
            ;;
        update)
            # Enable verbose output if requested
            if $verbose; then
                set -x
            fi
            cmd_update
            ;;
        status)
            cmd_status
            ;;
        backup)
            cmd_backup
            ;;
        clean)
            cmd_clean
            ;;
        uninstall)
            cmd_uninstall
            ;;
        *)
            log_error "Unknown command: $command"
            show_usage
            exit 1
            ;;
    esac
}

# Shell completion support
# This section provides completion functions that can be sourced from shell configs
# Usage: source <(dot --completion bash) or source <(dot --completion zsh)

show_bash_completion() {
    cat << 'EOF'
# Dotfiles management wrapper function
d() {
    local cmd="${1:-help}"
    if (($#)); then shift; fi

    case "$cmd" in
        h|health) "$HOME/.dotfiles/dot" health "$@" ;;
        s|status) "$HOME/.dotfiles/dot" status "$@" ;;
        u|update) "$HOME/.dotfiles/dot" update "$@" ;;
        b|backup) "$HOME/.dotfiles/dot" backup "$@" ;;
        c|clean)  "$HOME/.dotfiles/dot" clean "$@" ;;
        i|install) "$HOME/.dotfiles/dot" install "$@" ;;
        cd)       builtin cd "$HOME/.dotfiles" || return ;;
        *)        "$HOME/.dotfiles/dot" "$cmd" "$@" ;;
    esac
}

# Bash completion for dot script
_dot_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local commands="install status health update backup clean uninstall"
    # Bash 3.2 compatible (no mapfile)
    COMPREPLY=()
    while IFS= read -r word; do
        COMPREPLY+=("$word")
    done < <(compgen -W "$commands" -- "$cur")
}
complete -F _dot_completion dot

# Bash completion for d function wrapper
_d_completion_bash() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local commands="h health s status u update b backup c clean i install uninstall cd"
    # Bash 3.2 compatible (no mapfile)
    COMPREPLY=()
    while IFS= read -r word; do
        COMPREPLY+=("$word")
    done < <(compgen -W "$commands" -- "$cur")
}
complete -F _d_completion_bash d
EOF
}

show_zsh_completion() {
    cat << 'EOF'
# Dotfiles management wrapper function
d() {
    local cmd="${1:-help}"
    if (($#)); then shift; fi

    case "$cmd" in
        h|health) "$HOME/.dotfiles/dot" health "$@" ;;
        s|status) "$HOME/.dotfiles/dot" status "$@" ;;
        u|update) "$HOME/.dotfiles/dot" update "$@" ;;
        b|backup) "$HOME/.dotfiles/dot" backup "$@" ;;
        c|clean)  "$HOME/.dotfiles/dot" clean "$@" ;;
        i|install) "$HOME/.dotfiles/dot" install "$@" ;;
        cd)       builtin cd "$HOME/.dotfiles" || return ;;
        *)        "$HOME/.dotfiles/dot" "$cmd" "$@" ;;
    esac
}

# Zsh completion for dot script
_dot_completion() {
    local -a commands
    commands=(
        'install:Install dotfiles using GNU Stow'
        'status:Show installation status and recent backups'
        'health:Run comprehensive diagnostics'
        'update:Update configurations and reinstall'
        'backup:Create backup of existing files'
        'clean:Clean up backup directories'
        'uninstall:Remove dotfiles symlinks'
    )
    _describe 'dot command' commands
}
compdef _dot_completion dot

# Zsh completion for d function wrapper
_d_completion() {
    local -a commands
    commands=(
        'h:health - Comprehensive diagnostics'
        'health:Comprehensive diagnostics'
        's:status - Quick status check'
        'status:Quick status check'
        'u:update - Update and reinstall'
        'update:Update and reinstall'
        'b:backup - Create backup'
        'backup:Create backup'
        'c:clean - Clean up old backups'
        'clean:Clean up old backups'
        'i:install - Install dotfiles'
        'install:Install dotfiles'
        'uninstall:Remove dotfiles'
        'cd:Change to dotfiles directory'
    )
    _describe 'dotfiles command' commands
}
compdef _d_completion d
EOF
}

# Handle completion requests
if [[ "${1:-}" == "--completion" ]]; then
    case "${2:-}" in
        bash)
            show_bash_completion
            exit 0
            ;;
        zsh)
            show_zsh_completion
            exit 0
            ;;
        *)
            log_error "Unknown shell type: ${2:-}. Use 'bash' or 'zsh'"
            exit 1
            ;;
    esac
fi

# Run main function with all arguments
main "$@"
